<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Openwrt QSDK 坑</title>
    <url>/2021/03/11/Openwrt-QSDK/</url>
    <content><![CDATA[<p>最近接手我司路由器固件开发，作为对openwrt 以及QSDK完全没有经验和理解的小白，踩了一些坑，留篇笔记，以做纪念</p>
<a id="more"></a>
<ol>
<li>dts的目录在：qsdk/qca/src/linux-4.4/arch/arm(or arm64)/boot/dts</li>
</ol>
<p>修改板子的名称后，需要修改对应的生成网口的脚本添加匹配选项。脚本的目录在这：qsdk/target/linux/ipq/base-files/etc/uci-defaults</p>
<ol start="2">
<li><p>Qca-wpa 以及qca-hostapd 两个只要装完全版就好，不要多选，多选会程序冲突导致Wi-Fi无法正常启动， 通用的 wpa 以及 hostapd 不出意外的话会编译失败。</p>
</li>
<li><p>QSDK的luci并没有对qcawificfg80211做默认支持，所以需要去 luci/module/luci-mod-admin-full 那里修改model ， 添加判断条件。傻子都懂怎么添加。</p>
</li>
<li><p>尽量少对 nand flash 进行烧写，做调试的话，生成ipk装上就好了。 </p>
</li>
<li><p>luci nav上的”Openwrt”不是图片，也不是写死在主题里的 ， 而是主机名，要修改的话去修改主机名就好了，qsdk/package/base-files/files/etc/config/system</p>
</li>
<li><p>别想着opkg update了，网上压根没有15.05的软件源，除非你自己搭。</p>
</li>
<li><p>Openwrt 18.6 的luci 比起 QSDK的luci规则变了很多，不要以为是兼容的，具体语法自己进俩源码内对比，当然，别找我要QSDK源码，写这玩意是给已经有QSDK的人看的，希望他们别再踩坑。</p>
</li>
<li><p>乖乖用ubuntu 来编译，别傻逼逼的用arch或者deepin（我知道也是debian，但是软件源真的有问题）啥的，能节省各位很多时间。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>openwrt - unix</tag>
      </tags>
  </entry>
  <entry>
    <title>OVSDB管理协议 翻译</title>
    <url>/2019/05/22/OVSDB%20Protocol/</url>
    <content><![CDATA[<p>​        本文为翻译ovsdb管理协议 作为学习，原地址为 【<a href="https://tools.ietf.org/pdf/rfc7047.pdf" target="_blank" rel="noopener">RFC 7047</a>】</p>
<a id="more"></a> 
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在虚拟服务器环境中，需要一台虚拟交换机(virtual switch)来转发基于同一物理机的多台虚拟机 (VMs) 以及与物理网络之间的流量。</p>
<p>Open vSwitch【<a href="http://openvswitch.org/" target="_blank" rel="noopener">OVS</a>】是一款开源软件，专门设计作为虚拟交换机用以上述环境。OVS 使用 OVSDB ( Open vSwitch Database )  控制协议以及 OpenFlow 协议来进行程序拓展及控制使用。OVS 项目包含了开源的 OVSDB 客户端以及服务端的接口。</p>
<p>OVSDB管理协议使用 JSON【<a href="https://tools.ietf.org/pdf/rfc4627" target="_blank" rel="noopener">RFC4627</a>】 作为传输格式，并基于 JSON-RPC 1.0 【<a href="https://tools.ietf.org/pdf/rfc4627" target="_blank" rel="noopener">JSON-RPC</a>】版本。 </p>
<p>OVSDB的数据库模型( schema )的文档在【<a href="https://tools.ietf.org/pdf/rfc7047.pdf" target="_blank" rel="noopener">DB-SCHEMA</a> 】，这份文档说明该协议通过与数据库交流来管理和设置 ovs 实例。同时也意味着可以通过此文档查明当前使用的数据库模型( schema ) ，将与<a href="schema">4.1.2节</a>介绍 。</p>
<p><a href="http://openvswitch.org/ovs-vswitchd.conf.db.5.pdf" target="_blank" rel="noopener">OVSDB 管理协议</a> 是为了可以以编程的方式访问 OVSDB 。 该数据库存放着一个虚拟交换机（ vSwitch ）进程的配置。 通常该配置描述了该虚拟交换机的行为，而没有描述其路由系统的行为和配置。未来是否会涉及到路由系统的元素以及数据表的扩展，就需要留意 IETF 的 I2RS 工作组是否定义路由系统的实时或事件驱动交流的协议以及数据模型 。</p>
<h3 id="要求语言-（Requirements-Language）"><a href="#要求语言-（Requirements-Language）" class="headerlink" title="要求语言 （Requirements Language）"></a>要求语言 （Requirements Language）</h3><p>关键词 必须 “MUST” ,绝不 “MUST NOT “ , 必需 “REQUIRED” ,将要 “SHALL” ,将不能 “SHALL NOT” ,应当 “SHOULD” ,应当不 “SHOULD NOT” ,建议 “RECOMMENDED” ,可选的 “OPTIONAL” 。 具体描述在 <a href="https://tools.ietf.org/pdf/rfc2119" target="_blank" rel="noopener">RFC2119</a> 中。</p>
<h3 id="术语（Terminology）"><a href="#术语（Terminology）" class="headerlink" title="术语（Terminology）"></a>术语（Terminology）</h3><p>UUID ：通用唯一标识符（Universally Unique Identifier）。一段128位的标识符，在空间和时间上都是唯一的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Universally Unique Identifier.  A 128-bit identifier that</span><br><span class="line">is unique in space and time</span><br></pre></td></tr></table></figure>
<p>OVS: Open vSwitch. 一款开源的虚拟交换机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Open vSwitch.  An open-source virtual switch.</span><br></pre></td></tr></table></figure>
<p>OVSDB:  用以管理OVS实例的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The database that is used for the purpose of configuring</span><br><span class="line">OVS instances.</span><br></pre></td></tr></table></figure>
<p>JSON: Javascript 对象表示方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Javascript Object Notation</span><br></pre></td></tr></table></figure>
<p>JSON-RPC： JSON 远程调用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSON Remote Procedure Call</span><br></pre></td></tr></table></figure>
<p>Durable ： 对非可变形介质（如硬盘）的可靠性写入。ovsdb支持 是否指定传输为持久性的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reliably written to non-volatile storage (e.g., disk).</span><br><span class="line">OVSDB supports the option to specify whether or not</span><br><span class="line">transactions are durable.</span><br></pre></td></tr></table></figure>
<p>请注意，JSON <a href="https://tools.ietf.org/pdf/rfc4627" target="_blank" rel="noopener">RFC4627</a> 清晰地定义了一系列重要项目，比如 JSON 的 value ,object ,arrays,以及strings , 本文档在所有情况下皆使用 RFC4627 的定义。</p>
<h2 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h2><p>下图(Figure 1)描述了Open vSwitch 的主要构成， 以及控制和管理集群的接口。一个OVS实例由一个数据库服务器(ovsdb-server) ,一个虚拟交换机进程 (ovs-vswitchd) ,以及可选的可执行快速转发的模块组成。”Control &amp; Management Cluster”（控制及管理集群）指一定数量的Manager(管理器)和controller(控制器)。控制器们使用 OVSDB管理协议(OVSDB management protocol)去管理 OVS 实例或实例集群 。一个ovs实例由至少有一个管理器管理，控制器们使用openflow协议去为支持Openflow协议的交换机安装流表。一个ovs实例支持多个逻辑数据路径(logical datapaths) , 也就是作为网桥(bridges), 每一个Openflow网桥至少有一个控制器来控制。</p>
<p>OVSDB管理接口用以管理及配置OVS实例的操作。对比起OpenFlow, OVSDB管理操作作用于更长的时间段（时间窗口），以下为OVSDB所支持的操作例子:</p>
<ul>
<li>创建，修改，删除 OpenFlow 数据通路 ( 网桥 )，数据通路在单一OVS实例会有很多个。</li>
<li>配置控制器集去连接某一个OpenFlow数据通路</li>
<li>配置管理器集去连接某一个OVSDB服务器</li>
<li>创建，修改，删除 OpenFlow 数据通路的端口</li>
<li>创建，修改，删除 OpenFlow数据通路的隧道接口</li>
<li>创建，修改，删除 队列</li>
<li>配置QoS策略，并将该规则绑定到队列</li>
<li>收集统计数列。</li>
</ul>
<p>OVSDB并不会针对每一条流进行操作，这些事情留给OpenFlow去完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  +----------------------+</span><br><span class="line">  |       Control &amp;      |</span><br><span class="line">  |      Management      |</span><br><span class="line">  |       Cluster        |</span><br><span class="line">  +----------------------+</span><br><span class="line">    |              \</span><br><span class="line">    | OVSDB         \ OpenFlow</span><br><span class="line">    | Mgmt           \</span><br><span class="line">    |                 \</span><br><span class="line">+============================================+</span><br><span class="line">| +--------------+       +--------------+    |</span><br><span class="line">| |              |       |              |    |</span><br><span class="line">| | ovsdb-server |-------| ovs-vswitchd |    |</span><br><span class="line">| |              |       |              |    |</span><br><span class="line">| +--------------+       +--------------+    |</span><br><span class="line">|                                |           |</span><br><span class="line">|                        +----------------+  |</span><br><span class="line">|                        | Forwarding Path|  |</span><br><span class="line">|                        +----------------+  |</span><br><span class="line">+============================================+</span><br><span class="line">       Figure 1: Open vSwitch Interfaces</span><br></pre></td></tr></table></figure>
<p>以后的关于OVSDB管理协议的用法将在 <a href="http://openvswitch.org/ovs-vswitchd.conf.db.5.pdf" target="_blank" rel="noopener">DB-SCHEMA</a> 提供。</p>
<h2 id="OVSDB-结构"><a href="#OVSDB-结构" class="headerlink" title="OVSDB 结构"></a>OVSDB 结构</h2><p>这一章节将介绍OVSDB数据库结构的大纲，这里介绍的会比较讲简单明了，完整和目前的 OVS 数据库模型介绍请参考 <a href="http://openvswitch.org/ovs-vswitchd.conf.db.5.pdf" target="_blank" rel="noopener">DB-SCHEMA</a> ，也可以查看章节 4.1.2 来了解OVSDB管理协议如何用以当前数据库模型。</p>
<h3 id="JSON-用法"><a href="#JSON-用法" class="headerlink" title="JSON 用法"></a>JSON 用法</h3><p>​    ovsdb使用JSON格式作为其数据库模型(schema)以及通信协议(wire protocol)的格式。JSON格式在Open vSwitch有以下限制：</p>
<ul>
<li>空字节(\u000)不能在strings类型中使用</li>
<li>只支持UTF-8编码</li>
</ul>
<p><code>&lt;string&gt;</code> json的字符串格式 ，允许所有unicode字符串，使用时不允许用空字节</p>
<p><code>&lt;id&gt;</code> 一段符合<code>[a-zA-Z_][a-zA-Z0-9_]*</code>正则的字符串 ， <code>id</code> 以 <code>_</code> 开头并保留实现方式，不允许用户使用。</p>
<p><code>&lt;version&gt;</code> 一段表示版本号的 JSON 字符串， 满足 <code>[0-9]+\.[0-9]+\.[0-9]+</code></p>
<p><code>&lt;boolean&gt;</code> ture or false , 你懂的</p>
<p><code>&lt;number&gt;</code> 你懂的</p>
<p><code>&lt;integer&gt;</code> JSON number 类型实现的一个整数值 ， 范围：<code>-(2**63)…+(2**63)-1</code></p>
<p><code>&lt;json-value&gt;</code> 任何 JSON 值</p>
<p><code>&lt;nonull-json-value&gt;</code>  任何 JSON 非空值</p>
<p><code>&lt;error&gt;</code> 一段 JSON 对象包含下列成员</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">"error": &lt;string&gt;          required</span><br><span class="line">"details": &lt;string&gt;        optional</span><br><span class="line">			</span><br><span class="line">etc:</span><br><span class="line">"error": "resources exhausted"</span><br><span class="line"> The operation requires more resources (memory, disk, CPU, etc.)</span><br><span class="line">   than are currently available to the database server.</span><br><span class="line">   该操作对于当前使用的数据库服务器需要更多资源，如内存，硬盘，cpu之类的。</span><br><span class="line">"error": "I/O error"</span><br><span class="line">Problems accessing the disk, network, or other required</span><br><span class="line">   resources prevented the operation from completing.</span><br><span class="line">   硬盘、网络或者其他的内容来源拒绝了操作。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>sdn</tag>
      </tags>
  </entry>
  <entry>
    <title>黑果的尽头是白果</title>
    <url>/2021/11/25/black%20to%20white/</url>
    <content><![CDATA[<p>算是印证了标题，黑果玩到最后，不想折腾了，就会去买白果的。从去年m1发布后，我就一直在翘首以待下一代arm版的macbook pro，终于，10月20号，搭载m1 Pro/Max 的 macbook pro 发布了，在国区解锁购买的早上，我就火速购入了。</p>
<a id="more"></a>
<p>苹果也知道自己的东西贵，所以整了24期免息，对我这种虽然存好了钱但是不想一下子花光的人真是福音。我买的配置是16寸，Pro，32g，1tb，官网购入，23999，加上去大别那整的ac+，2450，总花费26449，其中23999分24期免息，每个月只要1000来块，和不要钱一样（笑。</p>
<p>本子从到货到现在已经用了两个星期了，该怎么说呢，一开始是很惊喜的，100%电的时候，我用pd虚拟机ubuntu来编译openwrt，从编译toolschain开始整，到完全编译完的整个过程，只花了50分钟，电只耗到了80%，是真的惊喜，而如果只是重编译一遍，不仅只需要3分钟，甚至连一格电都不会耗，这能效比，苹果是真的强的。</p>
<p>刚开始的时候电脑里面全是 Apple Silicon 的应用，是真的省电，到后面，钉钉，QQ音乐，向日葵啥的国内软件一一装上之后，续航可以看到是有所衰减的，毕竟中间件经历了一层转译。不过其实还好，毕竟再怎么耗电也比原来intel原生x86低。</p>
<p>游戏方面，用pd的arm windows11，毕竟玩的游戏中间也套了层windows的amd64 to arm64转译，性能我估计大约打了4折，只能说刚刚能用，毕竟，10帧能玩，20帧电竞。原生游戏还没玩过，看看几时有时间吧。</p>
<p>静音是真的静音，毕竟连续写代码编译两三个小时风扇转都不会转一下，只有跑benchmark和虚拟机3d游戏的时候才会转一下，而且温度也就保持在60摄氏度，使用体验是真的无敌。</p>
<p>音响，强的；空间音频，鸡肋。</p>
<p>屏幕，色彩，对比度，强；120hz ProMotion，只有在虚拟机windows才能全开，其他地方使用，动画120hz，应用60hz的感觉是真的有点割裂感，至于果冻屏，拖影，我是没那眼睛去识别了。甚至直接开true tone来护眼，去他妈的色彩管理。</p>
<p>以上就是两周来的总结了，到时看看用久点会如何。</p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>macOS - Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab CI/CD 教程</title>
    <url>/2019/08/16/gitlab-runner/</url>
    <content><![CDATA[<p>一开始是打算给自己博客整个CI然后自动部署，搞定的差不多之后就开始手痒，打算给公司的一个golang的项目也给CI/CD了， 然后就踏上了GitLab - CI/CD 的不归路。</p>
<a id="more"></a>
<p>其实安装过程的教程官网有:<a href="https://docs.gitlab.com/runner/install/" target="_blank" rel="noopener">GitLab</a>,就几条命令而已 。</p>
<h2 id="Installation-安装"><a href="#Installation-安装" class="headerlink" title="Installation 安装"></a>Installation 安装</h2><p>下载，根据linux的类型自行选择。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Linux x86-64</span></span><br><span class="line">sudo curl -L --output /usr/<span class="built_in">local</span>/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux x86</span></span><br><span class="line">sudo curl -L --output /usr/<span class="built_in">local</span>/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-386</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux arm</span></span><br><span class="line">sudo curl -L --output /usr/<span class="built_in">local</span>/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-arm</span><br></pre></td></tr></table></figure>
<p>然后给运行权限给 <code>gitlab-runner</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/gitlab-runner</span><br></pre></td></tr></table></figure>
<p>然后创建 <code>gitlab-runner</code> 的用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo useradd --comment <span class="string">'GitLab Runner'</span> --create-home gitlab-runner --shell /bin/bash</span><br></pre></td></tr></table></figure>
<p>安装<code>gitlab-runner</code> 的服务，然后跑起来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner</span><br><span class="line">sudo gitlab-runner start</span><br></pre></td></tr></table></figure>
<h2 id="Service-registration-服务注册"><a href="#Service-registration-服务注册" class="headerlink" title="Service registration 服务注册"></a>Service registration 服务注册</h2><p>然后给项目注册 <code>gitlab-runner</code> , 这时候需要一个<code>url</code>地址和一串<code>token</code> ，一句废话，这个<code>url</code> 必须可以让 <code>gitlab-runner</code>访问到 ， 不然连不通的。 这个地址在项目的 <code>gitlab.com/username/project/settings/ci_cd</code> 页面的<code>CI/CD</code> 的选项卡内 （本博客懒得找图床）。同时也有给<code>k8s</code>装<code>gitlab-runner</code>的选项，会看我博客的人用不上，用的上的人不会看我的博客，所以略过。</p>
<p>获得这俩值后开始注册 <code>gitlab-runner</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-runner register <span class="comment">#注册</span></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class="line"><span class="comment">#输入url</span></span><br><span class="line">Please enter the gitlab-ci token <span class="keyword">for</span> this runner</span><br><span class="line"><span class="comment">#输入token</span></span><br><span class="line">Please enter the gitlab-ci description <span class="keyword">for</span> this runner</span><br><span class="line"><span class="comment">#写点介绍</span></span><br><span class="line">Please enter the gitlab-ci tags <span class="keyword">for</span> this runner (comma separated):</span><br><span class="line"><span class="comment">#打tag，tag的作用等会说</span></span><br><span class="line">Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:</span><br><span class="line"><span class="comment">#选择运行器</span></span><br><span class="line"><span class="comment">#如果选择了 docker ， 选择一个默认镜像 ， 当.gitlab-ci.yml没有定义镜像时使用此默认镜像</span></span><br><span class="line">Please enter the Docker image (eg. ruby:2.1):</span><br><span class="line">alpine:latest</span><br></pre></td></tr></table></figure>
<h2 id="Configuration-File-配置文件"><a href="#Configuration-File-配置文件" class="headerlink" title="Configuration File 配置文件"></a>Configuration File 配置文件</h2><p>给项目加上<code>.gitlab-ci.yml</code> 文件 ， 以下是<code>golang</code>的示范文件 。 </p>
<p>我的环境时<code>shell</code> ， 也就是说下面文件所有的运行环境都是在<code>bin/sh</code> 输入command而已。 </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">export</span> <span class="string">GO_PROJECT_NAMESPACE="$GOPATH/src/gitexample.com/$CI_PROJECT_NAMESPACE"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">$GO_PROJECT_NAMESPACE</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">$GO_PROJECT_NAMESPACE</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ln</span> <span class="string">-srf</span> <span class="string">$(pwd)</span> <span class="string">$GO_PROJECT_NAMESPACE</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">export</span> <span class="string">GO_PROJECT_PATH="$GO_PROJECT_NAMESPACE/$CI_PROJECT_NAME"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">$GO_PROJECT_PATH</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">$GO_PROJECT_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">release</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">go</span> <span class="string">build</span>  </span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  	<span class="bullet">-</span> <span class="string">project-runner-tag</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">  	<span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">go</span> <span class="string">test</span> <span class="string">-v</span> <span class="string">./...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">release:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">release</span></span><br><span class="line">  <span class="attr">script:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">make</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./admin.sh</span> <span class="string">start</span></span><br><span class="line">  <span class="attr">allow_failure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>太明显的就懒得讲了，主要讲三个 , 一个是 <code>tags</code> ， 这个对应的是 <code>gitlab-runner</code>的<code>tag</code> . 而 <code>only</code> 代表这一 <code>stages</code>只有该分支需要运行 。还有一个 <code>except</code> ， 也就是说这一阶段除了这一分支都需要运行 。</p>
<p>如果你打算用 <code>docker</code> 来当运行器的话， 接下来的就可以略过了，节省时间。</p>
<h3 id="一个坑"><a href="#一个坑" class="headerlink" title="一个坑"></a>一个坑</h3><p>当在使用shell 环境的时候，默认的<code>gitlab-runner</code>使用的账户会经常碰到 <code>permission denied</code> 的问题 ， 临时解决方法是当你需要跑ci的时候上服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-runner run</span><br></pre></td></tr></table></figure>
<p>而一劳永逸的方法就是 ， 给<code>gitlab-runner</code>的账号提权。</p>
<ul>
<li><p>方法一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd gitlab-runner --shell /bin/bash -g root -G root <span class="comment">#直接在创建的时候给root权限就完事了。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>方法二</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -g root gitlab-runner <span class="comment">#修改分组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法三</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim /etc/sudoers </span></span><br><span class="line">修改: </span><br><span class="line"><span class="comment">## Allow root to run any commands anywhere</span></span><br><span class="line">root    				ALL=(ALL)     ALL</span><br><span class="line">gitlab-runner   ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法四</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim  /etc/passwd </span></span><br><span class="line">gitlab-runner:x:500:500:gitlab-runner:/home/gitlab-runner:/bin/bash</span><br><span class="line"><span class="comment">#修改成⬇️</span></span><br><span class="line">gitlab-runner:x:0:500:gitlab-runner:/home/gitlab-runner:/bin/bash</span><br></pre></td></tr></table></figure>
<p>以上四个方法来自 <a href="https://www.kancloud.cn/sgfoot/linux/481615" target="_blank" rel="noopener">linux 技术屋</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 的调度器 ： Ms , Ps 以及 Gs(翻译)</title>
    <url>/2020/07/23/gmp/</url>
    <content><![CDATA[<blockquote>
<p>注意，原文发布日期为2017年5月3日，至今已有3年 ， 而 go 语言已然从 1.10 进化到了 如今的 1.14 , 所以本篇的内容时效性并不做保证，仅用以学习理解。</p>
</blockquote>
<a id="more"></a> 
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>​    Go 的 <code>runtime</code> 调度器把 <code>goroutines</code> 映射为操作系统的线程，所以实质上， <code>goroutines</code>  是轻量化版本的，可以以极低的开销运作的线程。 所以 <code>gotoutines</code> 既是 <code>G.M.P</code> 模型里面的 <code>G</code> 。<code>runtime</code> 会追踪每一个 <code>G</code> ，并把他们映射到每一个逻辑处理器 (<code>Logical Processors</code>) ， 即 <code>P</code> 。<code>P</code> 可以看作是一种需要被获取到的抽象的资源或者上下文，以使系统的线程 (<code>OS thread</code>) 即  <code>M</code> (<code>Machine</code>) 可以执行 <code>G</code> 。</p>
<p>​    你可以通过  <code>runtime.GOMAXPROCS()</code> 来控制讲要使用的 <code>P</code> 的数量 。注意，这条命令尽量只执行一次，因为它会触发 <code>GC</code> ，并导致 <code>STW</code> 。</p>
<p>​    事实上，操作系统运行线程，也就是你的代码所运行的地方。 <code>Go</code> 做的 “把戏” 就是，使用编译器把不同系统的系统调用注入 go 的 <code>runtime</code> 内， 所以 Go 可以响应调度器并且执行动作。</p>
<p><a href="https://povilasv.me/go-scheduler/" target="_blank" rel="noopener"> 无图博客，原图请移步原文 </a></p>
<h2 id="在-Ms-Ps-Gs-间起舞吧（？"><a href="#在-Ms-Ps-Gs-间起舞吧（？" class="headerlink" title="在 Ms ,  Ps  , Gs 间起舞吧（？"></a>在 Ms ,  Ps  , Gs 间起舞吧（？</h2><p>  Ms , Ps , Gs 之间的交流有点复杂，噢，上帝，看看这美妙的流程图：</p>
<p><a href="https://povilasv.me/go-scheduler/" target="_blank" rel="noopener"> 无图博客，原图请移步原文 </a></p>
<p>我们可以看到， 这里有两种给 <code>G</code> 用的队列： 一个是实现于 <a href="https://github.com/golang/go/blob/master/src/runtime/runtime2.go" target="_blank" rel="noopener">schedt struct</a> ( 极少会被用到的 )的全局队列，以及每一个 <code>P</code>  所维护的一整套 可运行的 <code>G</code> 的队列 。</p>
<p>为了执行 goroutine  , <code>M</code> 需要维持一个 <code>context</code>(上下文) <code>P</code> 。然后<code>M</code>从 <code>P</code> 队列中推出 <code>goroutines</code> ，并执行代码。</p>
<p>当你调度了一个新的 goroutine （执行一个<code>go func()</code>），意味着你把它压入了 <code>P</code> 的队列，他们有一个很有趣的 <code>偷工作</code> 调度算法，当 <code>M</code> 完成执行了一些 <code>G</code> 后 ，它就会设法从队列中取出其他 <code>G</code> , 当其中一个 <code>P</code> 的队列空了之后 ， <code>G</code> 会从其他 <code>P</code> 中尝试 “偷” 掉一半的可执行的 <code>G</code> !</p>
<p>当你的 <code>goroutine</code> 做了一个阻塞性的系统调用(syscall)时，有趣的事情就发生了。 阻塞性的系统调用会被拦截， 如果当时有其他的 <code>G</code> 要执行时，<code>runtime</code> 会把这个线程从 <code>P</code> 中分离 ，并创建一个新的 OS 线程 （ 当闲置线程不存在时 ） ，来服务这个处理器。</p>
<p>当系统调用回复时，此 <code>goroutine</code> 会放回本地可执行队列，并且线程会自动释放（*此处用了park ，即停车，应该可以理解为释放为闲置资源。）(意味着线程不再使用) ， 并把自己写入闲置线程列表。</p>
<p>如果一个 <code>goroutine</code> 执行了一个网络调用，<code>runtime</code> 会做一相似的动作。这个调用会被拦截，但因为 Go 有一套拥有自己线程的<a href="https://morsmachine.dk/netpoller" target="_blank" rel="noopener">网络池</a> ， 它们会被分配到这些任务。</p>
<p>本质上，当目前的<code>gooutine</code> 被阻塞在：</p>
<ul>
<li>阻塞的系统调用（比如打开一个文件），</li>
<li>网络输入，</li>
<li>go channel 操作，</li>
<li>原生的 <code>sync</code>包调用。</li>
</ul>
<p>时，Go 的 <code>runtime</code> 会执行另外的 <code>goroutine</code> 。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>OVS学习中遇到的坑</title>
    <url>/2019/05/20/OVS%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>一些操作ovs流表常用的命令</p>
<a id="more"></a> 
<h2 id="ovs-ofctl"><a href="#ovs-ofctl" class="headerlink" title="ovs-ofctl"></a>ovs-ofctl</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ovs</span>-ofctl add-flows br0 (filename)  <span class="comment">#比如br0flow.txt 里面输入多条flow</span></span><br><span class="line"><span class="variable">$ovs</span>-ofctl add-flow br0 <span class="string">"arguments"</span> <span class="comment">#单条flow</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ovs</span>-ofctl del-flows in_port=1 <span class="comment">#删除所有in_port=1的流表</span></span><br></pre></td></tr></table></figure>
<h2 id="ovs-vsctl"><a href="#ovs-vsctl" class="headerlink" title="ovs-vsctl"></a>ovs-vsctl</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ovs</span>-vsctl add-br br0 <span class="comment">#网桥</span></span><br><span class="line"><span class="variable">$ovs</span>-vsctl del-br br0</span><br><span class="line"></span><br><span class="line"><span class="variable">$ovs</span>-vsctl add-port br0 port1 <span class="comment">#端口</span></span><br><span class="line"><span class="variable">$ovs</span>-vsctl del-port br0 port1</span><br><span class="line"></span><br><span class="line"><span class="variable">$ovs</span>-vsctl show --br(option)</span><br><span class="line"></span><br><span class="line"><span class="variable">$ovs</span>-vsctl list-br</span><br><span class="line"></span><br><span class="line"><span class="variable">$ovs</span>-vsctl <span class="built_in">set</span> port port1 tag=1 <span class="comment">#vlan1</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ovs</span>-vsctl <span class="built_in">set</span>-controller br0 tcp:10.1.2.8 <span class="comment">#设置控制器地址</span></span><br><span class="line"><span class="variable">$ovs</span>-vsctl get-controller br0</span><br></pre></td></tr></table></figure>
<p>当我们add了一个port的时候我们需要把该网口up起来才能使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ovs</span>-vsctl add-port br0 port1 tag=1 </span><br><span class="line"><span class="variable">$ovs</span>-vsctl <span class="built_in">set</span> Interface port1 <span class="built_in">type</span>=vxlan </span><br><span class="line"><span class="variable">$ifconfig</span> port1 192.168.1.2 up</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>sdn</tag>
      </tags>
  </entry>
  <entry>
    <title>go 单元测试</title>
    <url>/2019/06/17/gotesting/</url>
    <content><![CDATA[<p>目前最近的工作要接触一些有关于测试方面的知识，但是本人之前并没有做测试的经验，所以开始在网上做收集研究。接下来言归正传。</p>
<a id="more"></a> 
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>go 语言本身就自带了一个建议的测试库叫做 <code>testing</code>，使用方法蛮简单的 。</p>
<p>比如测试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="keyword">int</span>,i2 <span class="keyword">int</span>)</span>  <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i + i2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_add</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	sum := add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> sum == <span class="number">3</span>&#123;</span><br><span class="line">		t.Log(<span class="string">"ok"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		t.Fatal(<span class="string">"error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我这里的命名是 GoLand 自动生成的，而go标准的测试 func 名一般为<code>TestXXX</code> ，而文件名为 文件名_test.go 。</p>
<p>这里<code>t.Log()</code> 输出信息 , 并继续。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">=== RUN   Test_add</span><br><span class="line">--- PASS: Test_add (0.00s)</span><br><span class="line">    coding_test.go:8: ok</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>
<p><code>t.Fatal()</code> 标记为测试不通过，终止并输出错误信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">=== RUN   Test_add</span><br><span class="line">--- FAIL: Test_add (0.00s)</span><br><span class="line">    coding_test.go:10: error</span><br><span class="line">FAIL</span><br></pre></td></tr></table></figure>
<p>如果我们使用 <code>t.Error()</code>， 虽然测试不通过，但仍继续测试下去，适用在测试多 case 的时候。</p>
<p>而<code>Logf 、 Errorf  、Fatalf</code> 我就不多赘述，也就是format的意思。</p>
<p>当测试多案例的时候，我们可以使用goland或vscode 生成的测试方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_add</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">		i  <span class="keyword">int</span></span><br><span class="line">		i2 <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="keyword">string</span></span><br><span class="line">		args args</span><br><span class="line">		want <span class="keyword">int</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Add test cases.</span></span><br><span class="line">		&#123;<span class="string">"case 1"</span>,args&#123;<span class="number">1</span>, <span class="number">2</span>,&#125;,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"case 2"</span>,args&#123;<span class="number">2</span>, <span class="number">4</span>,&#125;,<span class="number">6</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> got := add(tt.args.i, tt.args.i2); got != tt.want &#123;</span><br><span class="line">				t.Errorf(<span class="string">"add() = %v, want %v"</span>, got, tt.want)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个参数为测试名称 ，第二为 我们需要传入的参数，当参数较多的时候，使用结构体 ， 第三个参数即我们最终需要的结果。查了下这种叫做 Table-Driven Test ，还蛮形象的 。</p>
<p>并行测试和基准测试以及覆盖率测试什么的我个人不大会，暂时略过，择日再写。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go学习笔记(2) — method</title>
    <url>/2019/06/18/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/</url>
    <content><![CDATA[<p>go的方法类让我这位php受害者难受的要死 ， 但是学习了一段时间之后，不得不说，go的类方法是真的牛批。不扯谈了，开始写文章。</p>
<a id="more"></a> 
<h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>Go 中可以把函数当作struct的字段一样处理，带有接收者的函数，成为method</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	MALE = <span class="literal">iota</span></span><br><span class="line">	FEMALE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> age <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age</span><br><span class="line">	gender <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> humanList []human</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	human</span><br><span class="line">	class <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">	human</span><br><span class="line">	school <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gender</span><span class="params">(g <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> g == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"male"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Female"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *human)</span> <span class="title">setAge</span><span class="params">(y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	h.age = age(y)</span><br><span class="line">	fmt.Printf(<span class="string">"this people name %s is age %v is a %s \n"</span>, h.name, h.age, gender(h.gender))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *teacher)</span> <span class="title">setAge</span><span class="params">(y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	t.age = age(y)</span><br><span class="line">	fmt.Printf(<span class="string">"this teacher name %s is age %v is a %s\n"</span>, t.name, t.age, gender(t.gender))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hl := humanList&#123;</span><br><span class="line">		human&#123;<span class="string">"jack"</span>, <span class="number">18</span>, MALE&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	hl[<span class="number">0</span>].setAge(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">	t := teacher&#123;human&#123;<span class="string">"jack"</span>, <span class="number">18</span>, MALE&#125;, <span class="string">"school"</span>&#125;</span><br><span class="line">	t.setAge(<span class="number">21</span>)</span><br><span class="line">	s := student&#123;human&#123;<span class="string">"jack"</span>, <span class="number">18</span>, MALE&#125;, <span class="string">"class"</span>&#125;</span><br><span class="line">	s.setAge(<span class="number">22</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道程序的输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this people name jack is age 20 is a male </span><br><span class="line">this teacher name jack is age 21 is a male</span><br><span class="line">this people name Marry is age 22 is a Female</span><br></pre></td></tr></table></figure>
<p>上面案例基本包含了method 的用法了</p>
<p>在go中，继承的实现非常的简单粗暴, 如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age</span><br><span class="line">	gender <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	human</span><br><span class="line">	class <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接把需要继承的父结构体包含进去就能使用父结构体的所有method了</p>
<p>而如果需要当多个结构体中，单个结构体想要重写父结构体的同名method的话，只需要</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *human)</span> <span class="title">setAge</span><span class="params">(y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	h.age = age(y)</span><br><span class="line">	fmt.Printf(<span class="string">"this people name %s is age %v is a %s \n"</span>, h.name, h.age, gender(h.gender))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *teacher)</span> <span class="title">setAge</span><span class="params">(y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	t.age = age(y)</span><br><span class="line">	fmt.Printf(<span class="string">"this teacher name %s is age %v is a %s\n"</span>, t.name, t.age, gender(t.gender))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不得不说真tm的简单粗暴……</p>
<p>我们发现，写 <code>setAge</code> 方法时，前面的 receiver 使用了指向 <code>human</code> 的指针，这是因为如果传入的是 <code>human</code>而不是<code>*human</code>的话，我们的方法操作对象将不是对<code>human</code>本身的引用，而是对<code>human</code>所传入的值进行修改 。</p>
<p>而当你使用 <code>*human</code> 的时候，在方法内并不需要<code>*h</code> 来进行修改，因为 go 判断你是要去修改指针所获取的值，在看资料的时候资料说加不加 <code>*</code>都可以，但我实际操作的时候发现加了<code>*</code>的话编译是不通过的，或许是go的版本问题吧。不过 <code>hl[0].setAge(20)</code> 这个写成   <code>(&amp;hl[0]).setAge(20)</code> 倒是可以 ，这是go自动转换的机制。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go学习笔记(3) — interface</title>
    <url>/2019/06/20/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)/</url>
    <content><![CDATA[<p>interfacce  翻译过来即是接口，这是种非常抽象的定义，即鸭子类型。（当一只鸟，会鸭子一样叫，会鸭子一样走路，会鸭子一样飞，我们就把它称作为鸭子）</p>
<a id="more"></a> 
<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h human)</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Hi I am %s"</span>,h.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> men <span class="keyword">interface</span> &#123;</span><br><span class="line">	sayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候我们定义好了一个 <code>men</code>的接口，并把<code>sayhi()</code>方法添加进了该接口。接下来我们看看这个是怎么使用的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  t := teacher&#123;human&#123;<span class="string">"jack"</span>, <span class="number">18</span>, MALE&#125;, <span class="string">"school"</span>&#125;</span><br><span class="line">  m := men(t)</span><br><span class="line">  m.sayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi I am jack</span><br></pre></td></tr></table></figure>
<p>可以发现，我们定义好了一个 <code>men</code> 接口 ，并用 <code>teacher</code> 方法实现了接口的调用。注意，此时 <code>teacher</code> 和<code>human</code>的除<code>sayHi()</code> 以外的方法都不能在 <code>men</code> 中调用，虽然这句有点废话，但是如果注意到这一点，也就知道  <code>interface</code> 这一定义的一大用处了。</p>
<p>go 的 public 和 private 实现并没有关键字，要靠定义方法的大小写来判断，如果我们的<code>men</code>接口是要对外开放的，我们就要把 <code>men</code> 改成 <code>Men</code> 。</p>
<p><code>interface</code> 还有一个有趣的用法，即空接口，当一个接口为空的时候，即 <code>interface{}</code>  ， 把该接口作为参数传入<code>func</code>，也就可以接受任何类型的值，当<code>func</code>返回值设置为<code>interface{}</code> 时，即可代表可返回任何类型的值，非常实用。</p>
<p><code>fmt.Println</code> 是我们常用的打印函数，当你打开他的源码定义是，即可看到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">  String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即任何 String 方法都能被作为参数被 <code>fmt.Println</code> 调用。</p>
<p>我们为 <code>human</code> 添加定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h human)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Jacky := human&#123;<span class="string">"jacky"</span>,<span class="number">18</span>,MALE&#125;</span><br><span class="line">  fmt.Println(<span class="string">"My name is"</span>,Jacky)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果应该猜到了，所以我就不再贴log了。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go学习笔记(5) —  panic,Recover</title>
    <url>/2019/06/27/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)/</url>
    <content><![CDATA[<p>Don’t Panic !</p>
<a id="more"></a>
<p>并不，只是在玩梗。</p>
<h2 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h2><p><code>panic</code> 作为内置函数，可以中断原有控制流程。go没有和java一样的异常抛出机制，而是使用了<code>panic</code>和<code>recover</code>机制。需要注意的是，这应当作为最后手段来使用，代码中不应该有或者说极少需要<code>panic</code>的东西。</p>
<p>当程序调用了<code>panic</code>，程序的执行被中断，但是<code>defer</code>的调用会正常执行。</p>
<h2 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h2><p>可以让<code>panic</code>了的<code>goroutine</code>恢复过来。<code>recover</code>仅在<code>defer</code>的过程中生效，正常情况调用recover会返回<code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicRecover</span><span class="params">(f <span class="keyword">func</span>()</span>) <span class="params">(b <span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> x := <span class="built_in">recover</span>();x!=<span class="literal">nil</span>&#123;</span><br><span class="line">      b = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  f()		<span class="comment">//if f() get panic , it will got to recover</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go学习笔记(4) —  iota , array ，slice , map</title>
    <url>/2019/06/24/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)/</url>
    <content><![CDATA[<p>第四篇，我都没想到我居然有毅力写到第四篇…..go学习笔记(4) —  iota , array ，slice , map</p>
<a id="more"></a>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="IOTA"><a href="#IOTA" class="headerlink" title="IOTA"></a>IOTA</h2><p>Go 的一个关键字，可以在声明enum的时候用，开始时默认值为0，<code>const</code> 中每增加一行 +1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  x = <span class="literal">iota</span>	<span class="comment">//x=0</span></span><br><span class="line">  y = <span class="literal">iota</span>	<span class="comment">//y=1</span></span><br><span class="line">  z	      	<span class="comment">//z=2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>常量声明省略值时，默认和之前的值相同，即 z 隐式地声明为 <code>iota</code>  , 所以 y 其实也可以省略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line"> x = <span class="literal">iota</span>	<span class="comment">//x=0</span></span><br><span class="line"> y = <span class="literal">iota</span>		<span class="comment">//y=1  </span></span><br><span class="line"> z	      	<span class="comment">//z=2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="literal">iota</span> <span class="comment">//v = 0</span></span><br></pre></td></tr></table></figure>
<p>当<code>iota</code>遇到下一个<code>const</code>， 会自动重置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	h,i,j = <span class="literal">iota</span> , <span class="literal">iota</span>, <span class="literal">iota</span>	<span class="comment">//h=0,i=0,j=0   </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>iota</code> 在同一行值相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a = <span class="literal">iota</span> <span class="comment">// a=0</span></span><br><span class="line">  b = <span class="string">"B"</span></span><br><span class="line">  c = <span class="literal">iota</span> <span class="comment">// c=2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>看到这里可以总结了，在同一<code>const</code>中，<code>iota</code> 随行数逐增。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p><code>array</code> 即是数组，<del>php程序员曾经的噩梦</del> ，定义方式如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [n]<span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p><code>n</code> 代表 数组长度，<code>type</code> 代表存储元素的类型。<br><small><br>Typora 今天出的bug有点多，晚点再找找有什么好的markdown编辑器。搜了一下，v友出的 <code>vnote</code>  ，可惜不能所见即所得，但是感觉还不错。大纲什么的功能让人觉得这玩意挺像IDE的。也可以使用hexo-admin来在线编辑。</small></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr[<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">13</span></span><br><span class="line">arr[<span class="number">9</span>]       <span class="comment">// 没有赋值时引用默认为 0 , 其他类型为nil</span></span><br></pre></td></tr></table></figure>
<p>当把数组作为参数传入函数时，我们其实传入的只是该数组的一副本，如果要进行操作，就需要用到 <code>*</code> 指针了。</p>
<p>数组可以使用 := 来声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a:=[<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">b:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;    <span class="comment">// 未赋值的索引值默认为0</span></span><br><span class="line">c:=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;    <span class="comment">//... go将根据有多少个值计算长度</span></span><br></pre></td></tr></table></figure>
<p>如果想声明多维数组的话</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mutiarray := [<span class="number">2</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例中，省略了内部类型的定义，以及如果索引值没有的话，和一维数组同样处理。</p>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>很多时候，数组不能满足我们的需求，当我们不知道需要定义多大的数组时，我们就需要”动态数组” ，该类型为 slice 。</p>
<p><code>slice</code> 并不是真正意义上的动态数组，而是一个引用类型。 <code>slice</code> 指向一个底层的 <code>array</code> , 所以<code>slice</code>的声明于 <code>array</code> 一样，只是不需要长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个数组</span></span><br><span class="line"><span class="keyword">var</span> ar = [<span class="number">10</span>]<span class="keyword">byte</span>&#123;<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 指向ar现有的元素，ar[1],ar[2],ar[3]</span></span><br><span class="line">a = ar[<span class="number">2</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>在 <code>[x:y]</code> 中 ， <code>x</code> 代表开始的位置，<code>y</code> 代表结束的位置，<code>x</code>的默认值为0，<code>y</code>的默认值为<code>len(array[])</code></p>
<p>对<code>slice</code> 有几个实用的内置函数</p>
<ul>
<li><code>len(slice())</code> 获取长度</li>
<li><code>cap(slice())</code> 获取容量</li>
<li><code>append(slice(),slice1())</code> 对slice追加元素，并返回slice</li>
<li><code>copy(slice())</code> ，复制，并返回复制元素的个数。</li>
</ul>
<p>还有一个用法是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice = array[<span class="number">2</span>:<span class="number">4</span>:<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>容量为7-2=5 ， 产生的slice无法访问最后三个元素。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>即<code>python</code>字典的概念，格式为 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```go</span><br><span class="line">var numbers map[string]int</span><br><span class="line">//也可以这么声明</span><br><span class="line">numbers := make(map[string]int)</span><br><span class="line"></span><br><span class="line">numbers[&apos;one&apos;] = 1 //赋值</span><br></pre></td></tr></table></figure></p>
<p>使用<code>map</code>的过程中，我们需要注意到，<code>map</code>是无序的，需要通过<code>key</code>来获取，不然的话每次便利的结果都会不一样。<code>map</code>的长度不固定的，与<code>slice</code>一样，都是引用类型。</p>
<p><code>len()</code> 函数适用于<code>map</code>，返回的是<code>map</code>所拥有<code>key</code>的数量。</p>
<p>需要注意的是，<code>map</code> 作为基本类型来说并非是进程安全(thread-safe)的，在多<code>go-routine</code> 存取时，必须使用<code>mutex lock</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(numbers,<span class="string">"one"</span>)		<span class="comment">//删除key为"one"的元素</span></span><br></pre></td></tr></table></figure>
<h2 id="make-new"><a href="#make-new" class="headerlink" title="make new"></a>make new</h2><p><code>make</code>用于内建类型的内存分配，<code>new</code>用于各种类型的内存分配。<code>new</code>返回的是指针，<code>make</code>返回的是初始化后的（非零）值。<code>make</code>只能用于创建<code>slice</code> 、<code>map</code>、<code>channel</code>，并填充适当的非空值。</p>
<h3 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>		<span class="number">0</span></span><br><span class="line"><span class="keyword">int8</span>   		<span class="number">0</span></span><br><span class="line"><span class="keyword">int32</span>		<span class="number">0</span></span><br><span class="line"><span class="keyword">int64</span>		<span class="number">0</span></span><br><span class="line"><span class="keyword">uint</span>		<span class="number">0x0</span></span><br><span class="line"><span class="keyword">rune</span>		<span class="number">0</span></span><br><span class="line"><span class="keyword">byte</span>		<span class="number">0x0</span></span><br><span class="line"><span class="keyword">float32</span>		<span class="number">0</span></span><br><span class="line"><span class="keyword">float64</span>		<span class="number">0</span></span><br><span class="line"><span class="keyword">bool</span>		<span class="literal">false</span></span><br><span class="line"><span class="keyword">string</span>		<span class="string">""</span></span><br></pre></td></tr></table></figure>
<p><del>为啥这次字能这么多？因为是边读 《go web编程》一边做的笔记</del></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go学习笔记(1) — 类型系统</title>
    <url>/2019/05/24/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>最近开始学go ，所以写一下记笔记。</p>
<a id="more"></a> 
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>Go语言提供了灵活的、无继承的类型系统，在无需降低运行性能的情况下最大程度的复用代码。</p>
<p>这个类型系统依然支持面向对象开发，但避免了传统面向对象的问题。go使用组合(composition)设计模式</p>
<p>只需简单的将一个类型嵌入到另一个类型，就能服用所有功能，在go语言中，一个类型有其他更微小的类型组合而成，避免了传统基于继承的模型。</p>
<p>另外，go语言有独特的接口实现机制，允许用户对行为进行建模，而不是对类型进行建模。在go语言中不需要声明某个类型实现了某个接口，编译器会判断一个类型的实例是否符合正在使用的接口。</p>
<ul>
<li>类型简单</li>
</ul>
<p>go语言不仅有类似int、string这样的内置类型，还支持用户自定义类型。go语言的用户定义的类型看起来和c语言的结构很像，用起来也很相似。与传统语言通过继承来扩展结构不同，go时使用不同的小类型组成一个大类型。</p>
<ul>
<li>go接口对一组行为建模</li>
</ul>
<p>接口用于描述类型的行为，如果一个类型的水实现了一个接口，意味着这个实例可以执行一组特定的行为。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go实战中的一些坑(1)</title>
    <url>/2019/09/26/go%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91-1/</url>
    <content><![CDATA[<p>一个关于<code>goroutine</code>的坑，与解决它的故事…</p>
<a id="more"></a>
<h2 id="坑的起源"><a href="#坑的起源" class="headerlink" title="坑的起源"></a>坑的起源</h2><p>这项目是公司缺人所以我来接手整一下前端，然后在测试一个地图页面的时候感觉到明显的延迟，原本以为是d3的svg地图渲染慢，正想着要不要换成canvas来加快渲染，然后我打开了开发者工具，发现这个接口整整需要4s来获取，这可是本地测试环境啊，这要是上线来整的话那不是凉凉？逐打开项目代码查看，这个接口程序非常简单，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, pro := <span class="keyword">range</span> prolist &#123;</span><br><span class="line">		statisticsModel, _ := model.GetProStatitics(pro.BELONG_PRO)</span><br><span class="line">		LineStatus := model.GetProLineStatusCount(pro.BELONG_PRO)</span><br><span class="line">		r := model.AreaStatisticsModel&#123;</span><br><span class="line">			Area: pro.BELONG_PRO,</span><br><span class="line">			Name: pro.NAME,</span><br><span class="line">			StatisticsModel: model.StatisticsModel&#123;</span><br><span class="line">				Totalcount:           statisticsModel.Totalcount,</span><br><span class="line">				Totalanomalies:       statisticsModel.Totalanomalies,</span><br><span class="line">				TotalTunnelAnomalies: LineStatus,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		areaStatisticsModels = <span class="built_in">append</span>(areaStatisticsModels, r)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>看了看，这不行啊，有点点拖，然后下手改造。</p>
<h2 id="开始挖坑"><a href="#开始挖坑" class="headerlink" title="开始挖坑"></a>开始挖坑</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, pro := <span class="keyword">range</span> prolist &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.done()</span><br><span class="line">    statisticsModel, _ := model.GetProStatitics(pro.BELONG_PRO)</span><br><span class="line">		LineStatus := model.GetProLineStatusCount(pro.BELONG_PRO)</span><br><span class="line">		r := model.AreaStatisticsModel&#123;</span><br><span class="line">			Area: pro.BELONG_PRO,</span><br><span class="line">			Name: pro.NAME,</span><br><span class="line">			StatisticsModel: model.StatisticsModel&#123;</span><br><span class="line">				Totalcount:           statisticsModel.Totalcount,</span><br><span class="line">				Totalanomalies:       statisticsModel.Totalanomalies,</span><br><span class="line">				TotalTunnelAnomalies: LineStatus,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		areaStatisticsModels = <span class="built_in">append</span>(areaStatisticsModels, r)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.wait()</span><br></pre></td></tr></table></figure>
<p>使用<code>waitgroup</code>与 <code>goroutine</code>进行 一个小小的改造，应该就这样吧，没问题的，不测试了，跑起来，草，127ms ，指数级增长的快感，地图瞬间渲染完成，这感觉，太爽了，正当着想着和同事吹吹，不经意间把鼠标移到地图上，发现所有的附加数据都是同一个数字，所有城市都是同一个名字，我心一惊，凉了 ，赶紧回滚回滚测试环境。</p>
<h2 id="埋坑"><a href="#埋坑" class="headerlink" title="埋坑"></a>埋坑</h2><p>主要问题在于主进程与gorouite进程的通讯如果不通过chanel的话，只有第一个参数复制了进去，所以接下来的所有操作都是用同一个参数进行操作。埋坑方法如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">proChan := <span class="built_in">make</span>(<span class="keyword">chan</span> AreaList,<span class="built_in">len</span>(prolist))</span><br><span class="line"><span class="keyword">for</span> _, pro := <span class="keyword">range</span> prolist &#123;</span><br><span class="line">  proChan &lt;- *pro</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.done()</span><br><span class="line">    pro :=&lt;- proChan</span><br><span class="line">    statisticsModel, _ := model.GetProStatitics(pro.BELONG_PRO)</span><br><span class="line">		LineStatus := model.GetProLineStatusCount(pro.BELONG_PRO)</span><br><span class="line">		r := model.AreaStatisticsModel&#123;</span><br><span class="line">			Area: pro.BELONG_PRO,</span><br><span class="line">			Name: pro.NAME,</span><br><span class="line">			StatisticsModel: model.StatisticsModel&#123;</span><br><span class="line">				Totalcount:           statisticsModel.Totalcount,</span><br><span class="line">				Totalanomalies:       statisticsModel.Totalanomalies,</span><br><span class="line">				TotalTunnelAnomalies: LineStatus,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		areaStatisticsModels = <span class="built_in">append</span>(areaStatisticsModels, r)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.wait()</span><br><span class="line"><span class="built_in">close</span>(proChan)</span><br></pre></td></tr></table></figure>
<p>这样就可以实现主进程与<code>goroutine</code>的通信。<code>go run .</code>测试，没问题，add , commit ,push, merge  一梭子上线测试环境，没问题，终于舒服了。</p>
<p>在改造其他有同样情况的接口时，我发现有<code>defer</code>和没有 ， 速度也是有区别的，想起之前看过的一篇<a href="https://colobu.com/2019/01/22/Runtime-overhead-of-using-defer-in-go/" target="_blank" rel="noopener">文章</a> ，<code>defer</code>在使用的时候的确会有延迟，总的来说就是靠效率来换取<code>recover</code>的安全…</p>
<p>然后又看到一篇煎鱼大大的<a href="https://mp.weixin.qq.com/s/nd_8vLy77HRlNSeBBHsPPQ" target="_blank" rel="noopener">文章</a> ，文章说go1.13的defer效率比以前高了大概30% ，过会升级看看。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go实战中的一些坑(2)</title>
    <url>/2019/10/20/go%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%9D%91-2/</url>
    <content><![CDATA[<p>这篇主要是纠正上一篇的补坑法….</p>
<a id="more"></a>
<h2 id="第一个坑"><a href="#第一个坑" class="headerlink" title="第一个坑"></a>第一个坑</h2><p>在上一篇文章我修改错误时是这么来整的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">proChan := <span class="built_in">make</span>(<span class="keyword">chan</span> AreaList,<span class="built_in">len</span>(prolist))</span><br><span class="line"><span class="keyword">for</span> _, pro := <span class="keyword">range</span> prolist &#123;</span><br><span class="line">  proChan &lt;- *pro</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.done()</span><br><span class="line">    pro :=&lt;- proChan</span><br><span class="line">    statisticsModel, _ := model.GetProStatitics(pro.BELONG_PRO)</span><br><span class="line">		LineStatus := model.GetProLineStatusCount(pro.BELONG_PRO)</span><br><span class="line">		r := model.AreaStatisticsModel&#123;</span><br><span class="line">			Area: pro.BELONG_PRO,</span><br><span class="line">			Name: pro.NAME,</span><br><span class="line">			StatisticsModel: model.StatisticsModel&#123;</span><br><span class="line">				Totalcount:           statisticsModel.Totalcount,</span><br><span class="line">				Totalanomalies:       statisticsModel.Totalanomalies,</span><br><span class="line">				TotalTunnelAnomalies: LineStatus,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		areaStatisticsModels = <span class="built_in">append</span>(areaStatisticsModels, r)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.wait()</span><br><span class="line"><span class="built_in">close</span>(proChan)</span><br></pre></td></tr></table></figure>
<p>但其实是可以不用 <code>channel</code> 的 ， 具体方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, pro := <span class="keyword">range</span> prolist &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(pro *model.AreaModel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.done()</span><br><span class="line">    pro :=&lt;- proChan</span><br><span class="line">    statisticsModel, _ := model.GetProStatitics(pro.BELONG_PRO)</span><br><span class="line">		LineStatus := model.GetProLineStatusCount(pro.BELONG_PRO)</span><br><span class="line">		r := model.AreaStatisticsModel&#123;</span><br><span class="line">			Area: pro.BELONG_PRO,</span><br><span class="line">			Name: pro.NAME,</span><br><span class="line">			StatisticsModel: model.StatisticsModel&#123;</span><br><span class="line">				Totalcount:           statisticsModel.Totalcount,</span><br><span class="line">				Totalanomalies:       statisticsModel.Totalanomalies,</span><br><span class="line">				TotalTunnelAnomalies: LineStatus,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		areaStatisticsModels = <span class="built_in">append</span>(areaStatisticsModels, r)</span><br><span class="line">	&#125;(pro)</span><br><span class="line">&#125;</span><br><span class="line">wg.wait()</span><br></pre></td></tr></table></figure>
<p>就完事了…. 所以说自大是真的不好，没个几年经验还是不要轻易的去帮忙修代码。</p>
<h2 id="第二个坑"><a href="#第二个坑" class="headerlink" title="第二个坑"></a>第二个坑</h2><p>当对于处理少量数据的时候，使用<code>goroutine</code>反而会拖慢系统的速度，因为<code>goroutine</code>的使用是需要额外开销的。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListBroken</span><span class="params">(city <span class="keyword">int</span>)</span> <span class="params">([]ClientListModel, <span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	clientSocket := <span class="built_in">make</span>([]ClientListModel, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">var</span> numCount <span class="keyword">int</span></span><br><span class="line">	topoJson := GetOperationalTopology()</span><br><span class="line">	remoteServerList := GetCityClientList(city)</span><br><span class="line">	<span class="keyword">for</span> _, remoteServer := <span class="keyword">range</span> remoteServerList &#123;</span><br><span class="line">		server := ClientListModel&#123;</span><br><span class="line">			ID:           remoteServer.ID,</span><br><span class="line">			VALIAS:       remoteServer.VALIAS,</span><br><span class="line">			VXLAN_STATUS: <span class="number">0</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		uid := remoteServer.UUID + <span class="string">"secret"</span></span><br><span class="line">		<span class="keyword">for</span> _, node := <span class="keyword">range</span> topoJson.Array() &#123;</span><br><span class="line">			<span class="keyword">if</span> !st.BoolContaits(uid, topoJson.String()) &#123;</span><br><span class="line">				server.VXLAN_STATUS = <span class="number">2</span></span><br><span class="line">				numCount++</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> st.BoolContaits(uid, node.Get(<span class="string">"secret"</span>).String()) &#123;</span><br><span class="line">				count := <span class="number">0</span></span><br><span class="line">				tpLines := GetJsonTerminationPoint(node)</span><br><span class="line">				<span class="keyword">for</span> _, tpId := <span class="keyword">range</span> tpLines.Array() &#123;</span><br><span class="line">					<span class="keyword">if</span> st.BoolContaits(remoteServer.VALIAS, tpId.Get(<span class="string">"secret"</span>).String()) &#123;</span><br><span class="line">						bfdStatusArray := tpId.Get(<span class="string">"secret"</span>)</span><br><span class="line">						<span class="keyword">for</span> _, bfdStatus := <span class="keyword">range</span> bfdStatusArray.Array() &#123;</span><br><span class="line">							<span class="keyword">if</span> bfdStatus.Get(<span class="string">"secret"</span>).String() == <span class="string">"secret"</span> &amp;&amp; bfdStatus.Get(<span class="string">"secret"</span>).String() == <span class="string">"secret"</span> &#123;</span><br><span class="line">								count++</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">if</span> bfdStatus.Get(<span class="string">"secret"</span>).String() == <span class="string">"secret"</span> &amp;&amp; bfdStatus.Get(<span class="string">"secret"</span>).String() == <span class="string">"secret"</span> &#123;</span><br><span class="line">								count++</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">if</span> bfdStatus.Get(<span class="string">"secret"</span>).String() == <span class="string">"secret"</span> &amp;&amp; bfdStatus.Get(<span class="string">"secret"</span>).String() == <span class="string">"secret"</span> &#123;</span><br><span class="line">								server.VXLAN_STATUS = <span class="number">1</span></span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">if</span> count == <span class="number">3</span> &#123;</span><br><span class="line">								server.VXLAN_STATUS = <span class="number">2</span></span><br><span class="line">								numCount++</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> server.VXLAN_STATUS == <span class="number">0</span> &#123;</span><br><span class="line">			server.VXLAN_STATUS = <span class="number">2</span></span><br><span class="line">			numCount++</span><br><span class="line">		&#125;</span><br><span class="line">		clientSocket = <span class="built_in">append</span>(clientSocket, server)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> clientSocket, numCount, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一段业务代码 , 如你所见…非常臃肿，在获取数据时的时候已经没了 5～7ms了 ，整段代码在测试环境跑完需要11ms左右，这还是因为需要验证的数据只有两条，生产环境下跑完这一段似乎需要整整300ms左右，所以我着手尝试改造…</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">clientSocket := <span class="built_in">make</span>([]ClientListModel, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">var</span> numCount <span class="keyword">int</span></span><br><span class="line">		topoJson := GetOperationalTopology()</span><br><span class="line">		remoteServerList := GetCityClientList(<span class="number">4401</span>)</span><br><span class="line">		wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> _, remoteServer := <span class="keyword">range</span> remoteServerList &#123;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(remoteServer *RemoteDeviceListModel)</span></span> &#123;</span><br><span class="line">				server := ClientListModel&#123;</span><br><span class="line">					ID:           remoteServer.ID,</span><br><span class="line">					VALIAS:       remoteServer.VALIAS,</span><br><span class="line">					VXLAN_STATUS: <span class="number">0</span>,</span><br><span class="line">				&#125;</span><br><span class="line">				uid := remoteServer.UUID + <span class="string">"secret"</span></span><br><span class="line">				topoJson.ForEach(<span class="function"><span class="keyword">func</span><span class="params">(key, value gjson.Result)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">					<span class="keyword">if</span> !st.BoolContaits(uid, topoJson.String()) &#123;</span><br><span class="line">						server.VXLAN_STATUS = <span class="number">2</span></span><br><span class="line">						numCount++</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> !st.BoolContaits(uid, value.Get(<span class="string">"secret"</span>).String()) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">					&#125;</span><br><span class="line">					count := <span class="number">0</span></span><br><span class="line">					value.Get(<span class="string">"secret"</span>).ForEach(<span class="function"><span class="keyword">func</span><span class="params">(key, value gjson.Result)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">						<span class="keyword">if</span> st.BoolContaits(remoteServer.VALIAS, value.Get(<span class="string">"secret"</span>).String()) &#123;</span><br><span class="line">							<span class="keyword">if</span> value.Get(<span class="string">"secret"</span>).String() == <span class="string">"secret"</span> &#123;</span><br><span class="line">								<span class="keyword">switch</span> value.Get(<span class="string">"secret"</span>).String() &#123;</span><br><span class="line">								<span class="keyword">case</span> <span class="string">"secret"</span>, <span class="string">"secret"</span>:</span><br><span class="line">									count++</span><br><span class="line">								<span class="keyword">case</span> <span class="string">"secret"</span>:</span><br><span class="line">									server.VXLAN_STATUS = <span class="number">1</span></span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">if</span> count == <span class="number">3</span> &#123;</span><br><span class="line">								server.VXLAN_STATUS = <span class="number">2</span></span><br><span class="line">								numCount++</span><br><span class="line">							&#125;</span><br><span class="line"></span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">					&#125;)</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">				&#125;)</span><br><span class="line">				<span class="keyword">if</span> server.VXLAN_STATUS == <span class="number">0</span> &#123;</span><br><span class="line">					server.VXLAN_STATUS = <span class="number">2</span></span><br><span class="line">					numCount++</span><br><span class="line">				&#125;</span><br><span class="line">				clientSocket = <span class="built_in">append</span>(clientSocket, server)</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;(remoteServer)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>这是一次失败的尝试 ，在改造中，我把原来的 <code>for range</code> 改成了 <code>gjson</code> 库自带的 <code>ForEach()</code> 。让我们看看这段代码实现了些啥…</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ForEach iterates through values.</span></span><br><span class="line"><span class="comment">// If the result represents a non-existent value, then no values will be iterated.</span></span><br><span class="line"><span class="comment">// If the result is an Object, the iterator will pass the key and value of each item.</span></span><br><span class="line"><span class="comment">// If the result is an Array, the iterator will only pass the value of each item.</span></span><br><span class="line"><span class="comment">// If the result is not a JSON array or object, the iterator will pass back one value equal to the result.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Result)</span> <span class="title">ForEach</span><span class="params">(iterator <span class="keyword">func</span>(key, value Result)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !t.Exists() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.Type != JSON &#123;</span><br><span class="line">		iterator(Result&#123;&#125;, t)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	json := t.Raw</span><br><span class="line">	<span class="keyword">var</span> keys <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> key, value Result</span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(json); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> json[i] == <span class="string">'&#123;'</span> &#123;</span><br><span class="line">			i++</span><br><span class="line">			key.Type = String</span><br><span class="line">			keys = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> json[i] == <span class="string">'['</span> &#123;</span><br><span class="line">			i++</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> json[i] &gt; <span class="string">' '</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> vesc <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(json); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> keys &#123;</span><br><span class="line">			<span class="keyword">if</span> json[i] != <span class="string">'"'</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			s := i</span><br><span class="line">			i, str, vesc, ok = parseString(json, i+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> vesc &#123;</span><br><span class="line">				key.Str = unescape(str[<span class="number">1</span> : <span class="built_in">len</span>(str)<span class="number">-1</span>])</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				key.Str = str[<span class="number">1</span> : <span class="built_in">len</span>(str)<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">			key.Raw = str</span><br><span class="line">			key.Index = s</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(json); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> json[i] &lt;= <span class="string">' '</span> || json[i] == <span class="string">','</span> || json[i] == <span class="string">':'</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		s := i</span><br><span class="line">		i, value, ok = parseAny(json, i, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		value.Index = s</span><br><span class="line">		<span class="keyword">if</span> !iterator(key, value) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次改造后，反而比原先的实现多了2ms左右时间开销。</p>
<p>总之就是为了兼容性多了很多对当前环境不必要的实现 ，多了一笔可观的消耗。虽然写的时候似乎比<code>for range</code> 美观（其实也没美观多少），但其实是非常的得不偿失的。而且其实在使用<code>.Array()</code>之后， 我们得到的是一个<code>slice</code> 对象，而不是<code>map</code> 对象 ，所以我们其实可以使用<code>for i:=0;i&lt;len(slice);i++</code> 来实现遍历，这样子虽然看着丑，但是性能实现其实比使用 <code>for range</code> 高整整一倍。<code>for range</code>比常规循环的具体原因是，它在实现遍历的同时，还需要对循环元素进行拷贝，而<code>slice[i]</code>是直接指针索引，性能肯定比拷贝快得多（<a href="https://www.flysnow.org/2018/10/20/golang-for-range-slice-map.html" target="_blank" rel="noopener">参考源</a> ）。</p>
<p>【修正 ： <code>for range</code> 可以直接只把<code>index</code> 索引出来。 】</p>
<p>然后我把代码修改为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">clientSocket := <span class="built_in">make</span>([]ClientListModel, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">var</span> numCount <span class="keyword">int</span></span><br><span class="line">		topoJson := GetOperationalTopology()</span><br><span class="line">		remoteServerList := GetCityClientList(<span class="number">4401</span>)</span><br><span class="line">		wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> _, remoteServer := <span class="keyword">range</span> remoteServerList &#123;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(remoteServer *RemoteDeviceListModel)</span></span> &#123;</span><br><span class="line">				server := ClientListModel&#123;</span><br><span class="line">					ID:           remoteServer.ID,</span><br><span class="line">					VALIAS:       remoteServer.VALIAS,</span><br><span class="line">					VXLAN_STATUS: <span class="number">0</span>,</span><br><span class="line">				&#125;</span><br><span class="line">				uid := remoteServer.UUID + <span class="string">"secret"</span></span><br><span class="line">				<span class="keyword">for</span> i := <span class="keyword">range</span> topoJson.Array() &#123;</span><br><span class="line">					<span class="keyword">if</span> !st.BoolContaits(uid, topoJson.String()) &#123;</span><br><span class="line">						server.VXLAN_STATUS = <span class="number">2</span></span><br><span class="line">						numCount++</span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> !st.BoolContaits(uid, topoJson.Array()[i].Get(<span class="string">"secret"</span>).String()) &#123;</span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line">					&#125;</span><br><span class="line">					count := <span class="number">0</span></span><br><span class="line">					<span class="keyword">for</span> j := <span class="keyword">range</span> topoJson.Array()[i].Get(<span class="string">"secret"</span>).Array() &#123;</span><br><span class="line">						value := topoJson.Array()[i].Get(<span class="string">"secret"</span>).Array()[j]</span><br><span class="line">						<span class="keyword">if</span> st.BoolContaits(remoteServer.VALIAS, value.Get(<span class="string">"secret"</span>).String()) &#123;</span><br><span class="line">							<span class="keyword">if</span> value.Get(<span class="string">"secret"</span>).String() == <span class="string">"secret"</span> &#123;</span><br><span class="line">								<span class="keyword">switch</span> value.Get(<span class="string">"secret"</span>).String() &#123;</span><br><span class="line">								<span class="keyword">case</span> <span class="string">"secret"</span>, <span class="string">"secret"</span>:</span><br><span class="line">									count++</span><br><span class="line">								<span class="keyword">case</span> <span class="string">"secret"</span>:</span><br><span class="line">									server.VXLAN_STATUS = <span class="number">1</span></span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">if</span> count == <span class="number">3</span> &#123;</span><br><span class="line">								server.VXLAN_STATUS = <span class="number">2</span></span><br><span class="line">								numCount++</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> server.VXLAN_STATUS == <span class="number">0</span> &#123;</span><br><span class="line">					server.VXLAN_STATUS = <span class="number">2</span></span><br><span class="line">					numCount++</span><br><span class="line">				&#125;</span><br><span class="line">				clientSocket = <span class="built_in">append</span>(clientSocket, server)</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;(remoteServer)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br></pre></td></tr></table></figure>
<p>这样子，就比原先的实现还少了2ms ， 这还是使用了<code>gorouite</code>的情况下。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Openwrt Clion 环境配置指南</title>
    <url>/2021/08/26/openwrt%20Clion%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>因为 <code>openwrt</code>对 golang 支持不佳，被迫写C，所以不得已使用 <code>Clion</code> 来对印度人的开源项目进行二次开发，印度人的项目使用的管理工具是  <code>autoconf</code> ，而 Clion 对 <code>autoconf</code>的支持实在不行，在经历了三个月纯粹把IDE当成 “有全局查找功能的编辑器” 后，忍无可忍 ，就有了创建独立于老代码的新项目，然后在老代码里引用新项目动态库的想法。</p>
<a id="more"></a>
<p>用 <code>Clion</code> 给 Openwrt 开发软件，首先得给 <code>Clion</code>配置上 <code>openwrt</code>的工具链，以 linux 上的 <code>Clion</code>为例 ， 在 <code>setting</code> -&gt; <code>Build,Execution,Deployment</code>-&gt; <code>ToolChains</code> 里，添加一个配置，把 Clion 所使用的 <code>CMake</code> ， <code>gcc</code>， <code>g++</code>配置为openwrt所用的版本 ，<code>CMake</code> 的目录一般在 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;openwrt_dir&#125;/staging_dir/host/bin/CMake</span></span><br></pre></td></tr></table></figure>
<p>而<code>gcc</code>以及<code>g++</code> 一般在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;openwrt_dir&#125;/staging_dir/toolchain-<span class="variable">$&#123;arch&#125;</span>_gcc_<span class="variable">$&#123;version&#125;</span>/bin/<span class="variable">$&#123;arch&#125;</span>-openwrt-linux-<span class="variable">$&#123;version&#125;</span>-&lt;gcc/g++&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样我们就配置好了 <code>Clion</code>所使用的编译器。</p>
<p>之后我们创建的项目是给 <code>openwrt</code> 创建的，所以需要用到 <code>openwrt</code>的动态库以及头文件。当你使用<code>Clion</code>来创建一个新项目的时候，会自动生成一个 <code>CMakeLists.txt</code> ，我们可以在这里做配置。因为我这里用的是老版本的 <code>CMake</code> 功能并不完全 ， 所以需要预定义好:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(CMAKE_FIND_LIBRARY_PREFIXES</span><br><span class="line">        <span class="string">"lib"</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_FIND_LIBRARY_SUFFIXES</span><br><span class="line">        <span class="string">".so"</span> <span class="string">".a"</span>)</span><br></pre></td></tr></table></figure>
<p>然后再定义我们头文件的目录:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;openwrt_dir&#125;</span>/staging_dir/<span class="keyword">target</span>-<span class="variable">$&#123;arch&#125;</span>_<span class="variable">$&#123;version&#125;</span>/usr/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>定义我们所需的动态库的目录:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;openwrt_dir&#125;</span>/staging_dir/<span class="keyword">target</span>-<span class="variable">$&#123;arch&#125;</span>_<span class="variable">$&#123;version&#125;</span>/usr/lib)</span><br></pre></td></tr></table></figure>
<p>定义好我们软件所需要的库</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIBS</span><br><span class="line">        ubox ubus uci json-c blobmsg_json sqlite3)</span><br></pre></td></tr></table></figure>
<p>然后把库与我们的执行程序链接在一起：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_program main.c)</span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(my_program <span class="variable">$&#123;LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们要编译的是一个动态库的话：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(my_libs libs.c)</span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(my_libs <span class="variable">$&#123;LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>这样，我们就拥有了一个在本机上编译目标openwrt平台软件的环境了。关于 <code>CMake</code>的软件开发及配置方法请自行参考资料，不做赘述。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>openwrt - debug</tag>
      </tags>
  </entry>
  <entry>
    <title>拯救黑苹果</title>
    <url>/2020/05/24/mac%20recover/</url>
    <content><![CDATA[<p>  由于穷的缘故，我一直使用 Hackintosh 作为我的主力开发机，当然，我一直以攒够钱就去买 macbook 为目标 ,然而这个目标更像是一个 flag ， 毕竟由于疫情原因，公司的生意确实没啥起色。而两周前，在完美升级完了 10.15.4 后，这台机子突然就睡死了，睡死之后就再也无法唤醒。于是开始了持续两周黑苹果拯救计划。</p>
<a id="more"></a>
<p>​    第一天和第二天都在尝试使用 OpenCore 和 Clover 来重新安装，耗费了我好多时间。看着报错一堆 “Apple nvme assert error” ，还以为是兼容性啥的出了问题，搜了几乎全网的解决方案，都没能搞定。然后同事叫我用 PE 进行看看磁盘，于是我顺手做了个 wepe 的盘拿来启动了我的电脑。用 diskgeniues 查看了一下磁盘，感觉没啥问题，然后又死不悔改的折腾了一天 ，直到我发现 nvme 盘的 efi 区虽然可读，但是却根本不能写之后，才确定了应该是磁盘主控啥的出了问题。</p>
<p> 好在浦科特的售后还是挺好的，维修总部似乎外包了给建兴来着，直接顺丰到付寄过去，经过了三天毫无音讯的等待，给我寄回了一条今年 3 月产的全新件，赚了赚了。而数据方面，因为一直都用公司的 nas 来做 timeMachine 所以也没啥损失的（苹果牛逼）。</p>
<p> 硬盘寄回来之后，我又不死心的折腾了一天 OC ， 然后在 pci 设备上栽了，因为 OC 的配置里需要你填好你 PCI 的所有硬件地址以及硬件名称与类型，然后我死活没办法把显卡给驱动起来，于是作罢。用 Clover 安装好然后用 TimeMachine 还原后，却一直没办法进入桌面，又折腾了一天，第二天早上灵光一闪，进 Recovery , 挂载系统盘， 进入 <code>/Library/Extensions</code> 文件夹，果然， 老版本的 Liui , whatevergreen 以及 AppleALC 都还在，而且因为非官方 kext 的缘故没办法在没有解锁的情况下建立 kextcache ，于是无法驱动进入桌面。于是我删掉了这几个 kext ， 因为现在的 kext 都是放在 efi 里面加载了的 ， 然后在磁盘目录下 输入： <code>kextcache -i /</code> 重建了官方缓存。关机重启，进入了桌面，时隔两周，终于搞定了。</p>
<p> 然而问题又来了，蓝牙挂了，一直找不到设备，明明几个挂起蓝牙的 kext 都已经加载好了啊。 于是又开始了爬资料、尝试修复、失败、重复爬资料的过程。最后我的目光落在了 USBPort.kext 上，这玩意我似乎以前都没见过啊，然后查了一下，这玩意是拿来定制黑苹果 USB 接口的，去除多余的接口并且开启 USB3 等等 。 这 USBPort.kext 是我从远景上同主板的帖子里扒下来的，也没想多少直接就用了。回忆了一下 ， 蓝牙那几个 Brcmbluetooth 的 kext 的原理似乎是创建一个虚拟的 usb hub ， 然后把蓝牙设备挂载在 usb hub 上 。 于是我去掉了 USBPort.kext ，并换上了 USBjinectAll.kext 开启了所有 USB 口，终于，蓝牙也修好了，我又开始愉悦地使用起了 Magic TrackPad 。而之后如果想要定制 USB 的话，感觉得花好多时间，到时候再说吧。 </p>
<p>修复这台玩意大概花了我两周时间，不过想了想我朋友的 Macbook Pro 18 上次坏也是坏了硬盘….也许苹果对硬盘的处理确实不大好。期间我甚至有 “算了直接用 windows + wsl ” 的想法，不过到最后终于还是把我这台黑果修复好了，可喜可贺，可喜可贺。</p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Clover</tag>
      </tags>
  </entry>
  <entry>
    <title>关于protobuf的json处理</title>
    <url>/2019/11/12/grpc%20oneof/</url>
    <content><![CDATA[<p>就打了那么久go代码了，一般需要处理json的时候一般都是Json Marshal Unmarshal一刷子搞定，但这次遇到了一个坑，那就是<code>marshal into interface{}</code>。</p>
<p>对于处理<code>marshal into interface{}</code>问题我之前都是使用<code>jsoniter</code>这个库来解决的，一般来说都能用，但这次是通过protobuf生成的文件，因为流表许多不同的结构，导致了protoc文件在同一字段使用了大量<code>oneof</code>来处理。也就导致了我们生成了一个看似<code>interface</code>而又有具体类型的结构。</p>
<p>主要解决还是这个的<code>Marshal form []byte</code>问题。其实解决方法很简单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get 	github.com/golang/protobuf/proto</span><br></pre></td></tr></table></figure>
<p>用这个包来处理<code>proto</code>的二进制转换以及<code>json</code>转换就好了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">()</span></span>&#123;</span><br><span class="line">  		<span class="keyword">var</span> data []<span class="keyword">byte</span></span><br><span class="line">  		protocMessage.Marshal(&amp;data)</span><br><span class="line">  		json.Unmarsahl(data,&amp;protocMessage)<span class="comment">// err: can not marsahl into interface&#123;&#125;</span></span><br><span class="line">			proto.Unmarshal(data, &amp;protocMessage)  <span class="comment">// success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个包是专门来处理 <code>protobuf</code>的转换问题的，都是没看官方文档惹的祸（</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Open Virtual Network 进程作用</title>
    <url>/2019/07/15/ovn%20%E8%BF%9B%E7%A8%8B%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>ovn 有两个运行进程，以下为作用。 </p>
<a id="more"></a>
<h3 id="The-Daemons"><a href="#The-Daemons" class="headerlink" title="The Daemons"></a>The Daemons</h3><ul>
<li><p>ovn-northd</p>
<ul>
<li>Converts from the high-level northbound DB to the run-time southbound DB.</li>
<li><p>从高层北向数据库转换到南向运行数据库</p>
</li>
<li><p>Generates logical flows based on high-level configuration.</p>
</li>
<li>基于高层（抽象）配置生成逻辑流表</li>
</ul>
</li>
<li><p>ovn-controller</p>
<ul>
<li>Register Chassis and VIFS to southbound DB</li>
<li>在北向数据库注册 Chassis （底盘 ，ovn新增的概念）以及 VIFS  ( Virtual network interfaces ) 信息</li>
<li>Converts logical flows into physical flows ( ie,vif UUIDs to openFlow Ports )</li>
<li>转换逻辑流表为物理流表（ 如转换虚拟网络接口为 openFlow 接口 ）</li>
<li>Pushes physical configuration to local OVS instance through OVSDB and OpenFlow</li>
<li>通过ovsdb与OpenFlow协议往本地ovs进程推送物理配置</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>sdn</tag>
      </tags>
  </entry>
  <entry>
    <title>春节至今的一两点琐事</title>
    <url>/2020/02/09/someshitpost/</url>
    <content><![CDATA[<p>也就没想到这台switch买的这么是时候。</p>
<a id="more"></a> 
<p>这些天因为大家都知道的那档事，呆家里呆了蛮久的，正当我在家玩switch咸鱼了半个月之际，猛的想起我毕设前端还没整，于是瞎几把抄起了键盘撸了个前端demo出来。其实快两年没写基于Nodejs的前端了，心来还是有点发虚，给垃圾笔记本win10切换到了慢速预览版，整上了wsl2，装上了docker，开起iTunes，听起了李宗盛，卸载了本身电脑里的nodejs和yarn，给wsl2里的ubuntu装上这俩玩意，因为wsl2会直接给你引用windows系统环境变量以及一些软件啥的。</p>
<p>整好yarn后，找了找<code>create-react-app</code> ，用这脚手架搭好了基础环境，然后找起了各大react入门博客看起，整着整着感觉不大对劲，<code>webpack.config.js</code>啥的就是起不了作用，突然想起有一个<code>yarn eject</code>的指令，然后搜了搜才知道这些玩意都被<code>create-react-app</code>集成进去了，要是要修改的话就需要释放所有配置文件出来，而且过程是不可逆的，释放出来之后，<code>react-script</code>啥的就不能平滑升级上去了，要是想修改的话，可以修改<code>/node_modules/react-scripts/config</code>里的文件，问题是<code>node_modules</code>是加进了<code>.gitignore</code>里的。最后找到了<code>react-app-rewired</code>，用它替换掉<code>package.json</code>里的<code>react-script</code>就可以导入自己设置的<code>webpack.config.js</code>了。问题是，找到了方法却发现自己其实根本没必要修改，因为其实这玩意本身已经很完善了，又一次被自己蠢哭了。</p>
<p>整完这些基础设置后就开始纠结前端框架了，最后还是选了<code>antd</code> ， 但是在写到一半的时候才发现 <code>antd</code>没有成熟的图形控件，突然就蛋疼了，不过想了想就是个破毕设，整这么多劳什子干啥，用轮播图控件顶一下就算了,于是就开开心心的瞎鸡儿写下去了。之后陆陆续续的补上了<code>react-router</code>和<code>redux</code>进去 ，草，怎么越来越大，越来越臃肿了？算了算了，开心就好。之后看了看<code>antd</code>有个<code>antd-pro</code>，可以直接设计后台，诶呦，这玩意不错，省了我不少功夫，后台的前端就靠这个了。</p>
<p>前几天<code>fitness-boxing</code>在hk eshop打折，原价300只要200就能入手了，刚好hk的eshop最近支持了支付宝，于是入手了，也就导致了我现在二头肌加背部酸痛的要死。之前用过同事的健身环大冒险，对比了一下，毕竟fb是打拳的，而健身环锻炼的是全身，健身环比fb累多了。</p>
<p>fb的玩法和音游一样，跟着节奏和屏幕提示来出拳，手感并不算特别好，只有打出<code>Just</code>（也就和音游pefect一样）的时候有感觉，当打出<code>Good</code>的时候，<code>Joycon</code>的反馈就会变小，人的节奏就会突然出现断点，打连招的节奏就会断掉，而且可能因为算法问题，右钩拳左勾拳左右上勾拳这些动作的判定都不大准确，有时候会在挥拳到一半时就判定为<code>Good</code>，这就有那么点蛋疼了。</p>
<p>总的来说在健身环被奸商炒到1200的这个时代，fb还是值得入手的，毕竟现在也不好出去锻炼嘛。而且，出拳出多了，hit数上去后，会解锁教练的衣服装饰，而且看板娘声优是早见沙织，而其他几位教练好像也是大牌声优来着？值了值了。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>Life</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么 goroutines 不是轻量化的线程</title>
    <url>/2020/08/24/why-goroutines-not-light-threads/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeburst.io/why-goroutines-are-not-lightweight-threads-7c460c1f155f" target="_blank" rel="noopener">原文地址</a><br>我没去获得授权来着，随手翻译一下就当做笔记了</p>
</blockquote>
<a id="more"></a>
<p>如今 golang 获得了从前不可想像的流行度，其主要原因是它那由 <code>goroutines</code> 与 <code>channels</code> 组合所提供简单且轻量的并发开发体验。</p>
<p>并发已经存在于线程很长一段时间，最近几乎所有应用都使用到了这一特性。</p>
<p>要去了解为什么 <code>goroutines</code> 并不是轻量化的线程，我们需要先了解线程如何在 <code>OS</code> 上进行工作。</p>
<p>如果你已经对线程很熟悉了，你可以直接<a href="##Goroutines">跳转到这</a>。</p>
<h2 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h2><p>一个线程既是可被一段可被处理器所执行的指令顺序，线程 ( Thread ) 比进程 ( process ) 更加轻量，所以我们可以产生并使用很多线程。</p>
<p>一个生动简单的的例子即 web 服务器。</p>
<p>一个 web 服务器必须得设计成去可在同一时间内处理多条不同的请求 。而且通常这些请求不会依赖对方。</p>
<p>所以线程就会被创建（ 或者从线程池内被取出 ），然后请求被委托给线程，已处理并发的情况。</p>
<p>现代处理器可以一次执行多个线程（多线程），并且切换不同的线程来实现并行性。</p>
<h2 id="线程比进程轻量吗？"><a href="#线程比进程轻量吗？" class="headerlink" title="线程比进程轻量吗？"></a>线程比进程轻量吗？</h2><p>是，也不是。</p>
<p>要先了解一下两个概念：</p>
<ul>
<li>线程分享内存，所以当它们被创建的时候，不需要创建新的虚拟内存空间，所以也并不需要用到 MMU(<code>memory management unit</code> 内存管理单元) 来进行上下文切换。</li>
<li>线程之间的交流使用的<code>分享内存</code>方法比起进程之间的交流需要各种方法如 <code>IPC</code> (<code>Inter-Process Communications</code> 进程内通讯) 的 信号 ，消息队列，管道等，都显得更加的轻量化。</li>
</ul>
<p>所以说，多进程处理在多核处理器中并非是保证高性能的不二法宝。</p>
<p>再比如 ， Linux 不区分线程以及处理器，并把他们都称为 多任务 <code>（Tasks）</code> 。当它们被克隆的时候，每一个任务都有其最大到最小的分享等级。</p>
<p>当你调用 <code>fork()</code> 的时候 , 一个新的，没有分享的文件描述符，没有 <code>PIDs</code>, 没有内存空间的任务<code>(task)</code>会被创建 。当你调用 <code>pthread_create()</code> 时，一个新的任务会被创建，并包含所有以上所被分享的资源。</p>
<p>当然，使用 分享内存 来同步化数据 以及 在多核情况下使用 L1 缓存 会造成比起在 不同线程上不同内存来同步时 更大的开销。</p>
<p>Linux 开发者们一直在致力于用最小的开销来切换任务，并且他们成功了。创建一个新的任务同窗比创建新的线程花销更大，但是切换任务却并非如此。</p>
<h2 id="还有什么可以对线程进行提升？"><a href="#还有什么可以对线程进行提升？" class="headerlink" title="还有什么可以对线程进行提升？"></a>还有什么可以对线程进行提升？</h2><p>这里有 3 种情况会让线程变慢：</p>
<ol>
<li><p>线程因为巨大的栈大小(&gt;= 1 MB ) 而消耗了过多的内存。所以创建 1000 个以上的线程即代表你需要整整 1 GB 的内存。</p>
</li>
<li><p>线程的回复 需要 一系列的寄存器，包括 <code>AVX(Advanced Vector extension)高级向量拓展指令集</code> , <code>SSE(Streaming SIMD Ext.流式单指令流多数据流拓展)</code> , 浮点寄存器 ，程序计数器<code>PC(Program Counter)</code>，栈指针<code>Stack Pointer(SP)</code>，等，都会对应用程序的性能造成影响。 3. 线程的创建与线程的销毁需要对系统资源（比如内存）进行的调用，会非常的慢。</p>
</li>
</ol>
<h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p><code>Goroutines</code> 只存在于 <code>go runtime</code>的虚拟空间内，而不在 <code>OS</code> 中。</p>
<p>所以， Go 的运行调度器需要管理其生命周期。</p>
<p>Go Runtime 调度器管理着 三个<code>C</code> 结构体：</p>
<ol>
<li>G: 相当于单个<code>go routine</code> , 并且包换了栈指针，基于栈，由它的 <code>ID</code> , 缓存，以及状态。</li>
<li>M: 代表了一个系统线程，其同时包含了一个全局可运行<code>goroutines</code> 队列 的指针，当前正在运行的<code>goroutine</code> ， 以及所关联的调度器。</li>
<li>调度架构：一个全局的结构体，和线程一样，但它包含的是空闲以及等待的<code>goroutines</code>的队列。</li>
</ol>
<p>所以，在启动的时候， <code>go runtime</code> 会启动一定数量的 goroutines 来处理<code>GC</code> ， 调度器，以及用户代码，一个<code>OS</code>的县城会被创建以处理这些 <code>goroutines</code> . 这些线程的数量将等同于<code>GOMAXPROCS</code> 。</p>
<h2 id="从下面开始！"><a href="#从下面开始！" class="headerlink" title="从下面开始！"></a>从下面开始！</h2><p><strong>一个 goroutine 被创建的时候仅仅占用 2kb 的栈大小。</strong> ， 每个 go 函数都已经做好了是否需要更多栈，以及栈是否能被其他两倍内存大小的内存来源所复制的检查。这使 <code>goroutines</code> 在资源使用上更加轻量。</p>
<h2 id="阻塞是无妨的！"><a href="#阻塞是无妨的！" class="headerlink" title="阻塞是无妨的！"></a>阻塞是无妨的！</h2><p>如果一个 <code>goroutine</code> 在系统上的调用了，他会阻塞整个线程。但其他线程会从调度器上取出等待队列，并且用其他可运行 <code>goroutines</code> 来执行。</p>
<p>然而，<strong>如果你使用 <code>Channel</code> 这种只存在于虚拟空间的方式来沟通，系统并不会阻塞线程。</strong> 这样的 <code>gorouintes</code> 简化了 go 在等待阶段，以及其他可运行 <code>goroutines</code>（在 <code>M</code> 内） 的调度。</p>
<h2 id="请勿中断！"><a href="#请勿中断！" class="headerlink" title="请勿中断！"></a>请勿中断！</h2><p>go 的运行时调度器做到了合作的调度，这意味着其他的 <code>goroutines</code> 只会因为当前使用的 <code>goroutine</code> 在阻塞或者已经完成时才会调用 ， 如以下情况：</p>
<ul>
<li>当这些操作会造成阻塞时， <code>Channel</code> 的发送或者接收。</li>
<li><code>Go</code> 的声明阶段，因为这并不会保证新的 <code>goroutine</code> 会被直接调度。</li>
<li>阻塞的系统调用，比如文件以及网络操作。</li>
<li>被 <code>gc</code> 过程所停止之后。</li>
</ul>
<p>这比基于时序系统(每 10ms 一次)的强占调度要更好，后者会造成阻塞，并调度一个新的线程。这可能会导致任务花更多的时间在 线程数增加 以及在处理 在有低优先级的任务运行时 的 更高优先级的任务的调度。</p>
<p>另外的好处是，因为这些逻辑都是在代码中隐式调用的，当睡眠以及 <code>Channel</code> 等待时，便一直只需要确保/恢复以下几个寄存器。在 Go 中，这意味着在进行上下文切换时仅仅需要调度 3 个寄存器：<code>PC</code> , <code>SP</code>, <code>DX(Data Registers)</code> ，而不是需要所有的寄存器，如（<code>AVX</code> , 浮点寄存器， <code>MMX</code>）。</p>
<p>如果你打算浏览更多关于 go 的并发原理， 你可以查阅下列链接:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=cN_DpYBzKso&amp;t=441s" target="_blank" rel="noopener">Concurrency is not parallelism by Rob Pike</a></li>
<li><a href="http://www1.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf" target="_blank" rel="noopener">Analysis of Go runtime Scheduler</a></li>
<li><a href="https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast" target="_blank" rel="noopener">Five things that make Go fast by Dave Cheney</a></li>
<li><a href="https://groups.google.com/forum/#!msg/golang-nuts/j51G7ieoKh4/wxNaKkFEfvcJ" target="_blank" rel="noopener">Discussion in golang-nuts mailing list</a></li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Switch 还是 If ， 这是个问题</title>
    <url>/2019/07/30/switch%20or%20if%20/</url>
    <content><![CDATA[<p>golang的语法里，选择判断的语句有 <code>switch case</code> <code>if else</code> <code>select case</code> 这三个组合。而 <code>select case</code> 通常是搭配 <code>channel</code> 类型使用的，所以暂时不在这篇文章的讨论范围。</p>
<a id="more"></a>
<p>通常来说我们更倾向于使用 <code>switch case</code> 而不是 <code>if else</code> ， 因为前者更加优雅清晰 ， 而且在 c 中，编译器有对<code>switch</code> 语句进行优化 —&gt;<a href="http://zenlife.tk/go-switch-statement.md" target="_blank" rel="noopener">出处</a> 。而 golang 因为没有和c一样生成跳转表，golang 的<code>switch</code> 实现是通过二分法(v1.7.2)来实现的。所以有人测出在超多分支的情况下 ， golang的 <code>switch</code> 比起<code>map</code> 后<code>if else</code> 要慢 ，因为命中率太低了。而小分支的情况下，性能的差距是很小而基本可以忽略的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSwitch</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	arra := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		rand.Seed(time.Now().Unix())</span><br><span class="line">		a := rand.Intn(<span class="number">3</span><span class="number">-0</span>) + <span class="number">0</span></span><br><span class="line">		<span class="keyword">switch</span> arra[a] &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">			<span class="built_in">print</span>(arra[a])</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">			<span class="built_in">print</span>(arra[a])</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"c"</span>:</span><br><span class="line">			<span class="built_in">print</span>(arra[a])</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"d"</span>:</span><br><span class="line">			<span class="built_in">print</span>(arra[a])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkIF</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	arra := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"></span><br><span class="line">		rand.Seed(time.Now().Unix())</span><br><span class="line">		a := rand.Intn(<span class="number">3</span><span class="number">-0</span>) + <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> arra[a] == <span class="string">"a"</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(arra[a])</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> arra[a] == <span class="string">"b"</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(arra[a])</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> arra[a] == <span class="string">"c"</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(arra[a])</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> arra[a] == <span class="string">"d"</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(arra[a])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是测试结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BenchmarkSwitch-8   	  200000	      7612 ns/op</span><br><span class="line">BenchmarkIF-8   	  		200000	      7624 ns/op</span><br></pre></td></tr></table></figure>
<p>可以看出来，小分支的情况下，性能和 <code>if</code> 比起来甚至会超过 <code>if</code> (Golang v1.12.6) 。 </p>
<p>所以，在使用 golang 的过程中，如果不是极度需要考虑到性能的情况，为了代码的优雅，请多多使用<code>switch</code> !</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>tldr</title>
    <url>/2019/05/27/tldr/</url>
    <content><![CDATA[<p>推荐一命令行神器：<a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">tldr</a></p>
<p>具体用法看github主页，个人感觉比man好用</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title>Phalcon微信后台开发指北</title>
    <url>/2018/09/21/phalcon%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<p>这是我的一个个人项目,基于Phalcon的mvc应用,拥有后台管理以及api输出的功能,暂时只有修改菜单并输出json的功能(哭)</p>
<a id="more"></a> 
<h1 id="Phalcon微信后台开发指北"><a href="#Phalcon微信后台开发指北" class="headerlink" title="Phalcon微信后台开发指北"></a>Phalcon微信后台开发指北</h1><h2 id="基于Phalcon-4-x-文档与3-x通用"><a href="#基于Phalcon-4-x-文档与3-x通用" class="headerlink" title="基于Phalcon 4.x ,文档与3.x通用"></a>基于Phalcon 4.x ,文档与3.x通用</h2><p>根据Phalcon 官网教程安装Phaclon<br>这里是phalcon爱好者翻译的中文文档,内容翻译的也差不多了，如果看不懂官网的英文的话可以在这里学习。</p>
<p>安装好 Phaclon devtool后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:JackyCZJ/phalcon-Wechat-Order.git</span><br><span class="line">$ <span class="built_in">cd</span>  phalcon-Wechat-Order</span><br><span class="line">$ composer install</span><br></pre></td></tr></table></figure>
<p>这里引用了论坛大佬的autoload代码 如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//app/config/loader.php</span></span><br><span class="line"></span><br><span class="line">$loader = <span class="keyword">new</span> \Phalcon\Loader();</span><br><span class="line"></span><br><span class="line">$namespace = [</span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- We're a registering a set of directories taken from the configuration file</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">$map = <span class="keyword">require</span> $config-&gt;application-&gt;vendorDir.<span class="string">'composer/autoload_namespaces.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($map <span class="keyword">as</span> $k =&gt; $values) &#123;</span><br><span class="line">    $k = trim($k, <span class="string">'\\'</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($namespaces[$k])) &#123;</span><br><span class="line">        $dir = <span class="string">'/'</span> . str_replace(<span class="string">'\\'</span>, <span class="string">'/'</span>, $k) . <span class="string">'/'</span>;</span><br><span class="line">        $namespaces[$k] = implode($dir . <span class="string">';'</span>, $values) . $dir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$loader-&gt;registerNamespaces($namespaces);</span><br><span class="line"></span><br><span class="line">$classMap = <span class="keyword">require</span> $config-&gt;application-&gt;vendorDir . <span class="string">'composer/autoload_classmap.php'</span>;</span><br><span class="line"></span><br><span class="line">$loader-&gt;registerClasses($classMap);</span><br><span class="line"></span><br><span class="line">$loader-&gt;registerDirs(</span><br><span class="line">    [</span><br><span class="line">        $config-&gt;application-&gt;controllersDir,</span><br><span class="line">        $config-&gt;application-&gt;modelsDir</span><br><span class="line">    ]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$loader-&gt;register();</span><br></pre></td></tr></table></figure>
<p>特此感谢</p>
<p>然后找到  <code>app/config/config.php </code> 修改数据库信息</p>
<p><code>~phalcon migration run  #迁移数据库</code></p>
<p>然后就可以跑起来了</p>
<p>个人觉得微信小程序自动生成的开发环境就是个弟弟,官方完全没有本地调试的doc,全靠自己摸索,要不然就要用官方的云开发环境,而云开发环境只有CI框架和node.js两个选择,完全没想过让开发者自己配置…不过毕竟是免费的,也不能要求太多</p>
<p>导入wafer的数据库cAuth.sql文件</p>
<p>不过我们其实可以把cAuth导入到我们应用的数据库然后再修改wafer2的数据库名,这样就不用弄两个数据库了</p>
<p>我们还要修改wafer2套件里面的config<br>vendor-&gt;qcloud-weapp-sdk-&gt;Conf.php<br>本地调试中我们主要要修改一下几个选项</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> $Mysql = [</span><br><span class="line">       <span class="string">'host'</span> =&gt; <span class="string">'localhost'</span>,</span><br><span class="line">       <span class="string">'port'</span> =&gt; <span class="number">3306</span>,</span><br><span class="line">       <span class="string">'user'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line">       <span class="string">'db'</span>   =&gt; <span class="string">'cAuth'</span>,</span><br><span class="line">       <span class="string">'pass'</span> =&gt; <span class="string">'*'</span>,</span><br><span class="line">       <span class="string">'char'</span> =&gt; <span class="string">'utf8mb4'</span></span><br><span class="line">   ];</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> $QcloudAppId = *;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 腾讯云 QcloudSecretId</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> $QcloudSecretId = <span class="string">'*'</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 腾讯云 QcloudSecretKey</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> $QcloudSecretKey = <span class="string">'*'</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 微信消息通知 token</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> $WxMessageToken = <span class="string">'weixinmsgtoken'</span>;</span><br><span class="line"><span class="comment">//这里开始跑题</span></span><br></pre></td></tr></table></figure>
<p>Phalcon的代码非常的简洁明了，而且组件模块化，当你想要只想创建一个微服务而不是MVC应用的话，可以直接引用micro组件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Phalcon</span>\<span class="title">Mvc</span>\<span class="title">Micro</span>;</span><br><span class="line"></span><br><span class="line">$app = <span class="keyword">new</span> Micro();</span><br><span class="line"></span><br><span class="line">$app-&gt;get(</span><br><span class="line">    <span class="string">"/say/welcome/&#123;name&#125;"</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">($name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;h1&gt;Welcome $name!&lt;/h1&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$app-&gt;handle();</span><br></pre></td></tr></table></figure>
<p>就这样我们就创建了一个简单的微服务</p>
<p>要与微信联动，我们就需要用到wafer2的php套件，官方演示是用CI框架，（早知道一开始就用CI写了，哭泣） 个人觉得CI在开发上非常的方便，而且效率高，但是似乎没办法提供micro service？（未验证）但是phalcon是php的c拓展，虽然在跑分上比CI低，但是实际使用上，<br>CI比起phalcon还是有所不如，而且CI框架的官网….怎么说呢,明明CI4.0已经发布了为啥还在说最新版本为3.1.9..</p>
<p>这里写一下在MVC架构下,weixin的controller写法</p>
<h3 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">QCloud_WeApp_SDK</span>\<span class="title">Auth</span>\<span class="title">LoginService</span> <span class="title">as</span> <span class="title">LoginService</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">QCloud_WeApp_SDK</span>\<span class="title">Constants</span> <span class="title">as</span> <span class="title">Constants</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeixinController</span> <span class="keyword">extends</span> \<span class="title">Phalcon</span>\<span class="title">Mvc</span>\<span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//用以处理微信事务的控制器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">indexAction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">die</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">LoginAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $result = LoginService::login();      <span class="comment">//引用wafer2套件的登陆</span></span><br><span class="line">         <span class="keyword">if</span> ($result[<span class="string">'loginState'</span>] === Constants::S_AUTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;setJsonContent([</span><br><span class="line">            <span class="string">'code'</span> =&gt; <span class="number">0</span>,</span><br><span class="line">            <span class="string">'data'</span> =&gt; $result[<span class="string">'userinfo'</span>]           <span class="comment">//返回用户信息</span></span><br><span class="line">        ]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;setJsonContent([</span><br><span class="line">            <span class="string">'code'</span> =&gt; <span class="number">-1</span>,</span><br><span class="line">            <span class="string">'error'</span> =&gt; $result[<span class="string">'error'</span>]             <span class="comment">//返回登陆错误信息</span></span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">UserAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $result = LoginService::check();              <span class="comment">//引用wafer2的确认方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($result[<span class="string">'loginState'</span>] === Constants::S_AUTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;setJsonContent([</span><br><span class="line">            <span class="string">'code'</span> =&gt; <span class="number">0</span>,</span><br><span class="line">            <span class="string">'data'</span> =&gt; $result[<span class="string">'userinfo'</span>]              <span class="comment">//根据数据库中存储的登录状态判断用户是否登陆过，嘤嘤嘤</span></span><br><span class="line">        ]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;setJsonContent([</span><br><span class="line">            <span class="string">'code'</span> =&gt; <span class="number">-1</span>,</span><br><span class="line">            <span class="string">'data'</span> =&gt; []</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Micro-Services"><a href="#Micro-Services" class="headerlink" title="Micro Services"></a>Micro Services</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Phalcon</span>\<span class="title">Mvc</span>\<span class="title">Micro</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">QCloud_WeApp_SDK</span>\<span class="title">Auth</span>\<span class="title">LoginService</span> <span class="title">as</span> <span class="title">LoginService</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">QCloud_WeApp_SDK</span>\<span class="title">Constants</span> <span class="title">as</span> <span class="title">Constants</span>;</span><br><span class="line"></span><br><span class="line">$app = <span class="keyword">new</span> Micro();</span><br><span class="line"></span><br><span class="line">$app-&gt;get(</span><br><span class="line">    <span class="string">"/Login"</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        $result = LoginService::login();                <span class="comment">//引用wafer2套件的登陆</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($result[<span class="string">'loginState'</span>] === Constants::S_AUTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;setJsonContent([</span><br><span class="line">            <span class="string">'code'</span> =&gt; <span class="number">0</span>,</span><br><span class="line">            <span class="string">'data'</span> =&gt; $result[<span class="string">'userinfo'</span>]           <span class="comment">//返回用户信息</span></span><br><span class="line">        ]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;setJsonContent([</span><br><span class="line">            <span class="string">'code'</span> =&gt; <span class="number">-1</span>,</span><br><span class="line">            <span class="string">'error'</span> =&gt; $result[<span class="string">'error'</span>]             <span class="comment">//返回登陆错误信息</span></span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">$app-&gt;get(</span><br><span class="line">    <span class="string">"/User"</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">         $result = LoginService::check();              <span class="comment">//引用wafer2的确认方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($result[<span class="string">'loginState'</span>] === Constants::S_AUTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;setJsonContent([</span><br><span class="line">            <span class="string">'code'</span> =&gt; <span class="number">0</span>,</span><br><span class="line">            <span class="string">'data'</span> =&gt; $result[<span class="string">'userinfo'</span>]              <span class="comment">//根据数据库中存储的登录状态判断用户是否登陆过，嘤嘤嘤</span></span><br><span class="line">        ]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;setJsonContent([</span><br><span class="line">            <span class="string">'code'</span> =&gt; <span class="number">-1</span>,</span><br><span class="line">            <span class="string">'data'</span> =&gt; []</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$app-&gt;handle();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在小程序内配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 小程序配置文件</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> host = <span class="string">'http://localhost'</span>; <span class="comment">// 此处主机域名修改成腾讯云解决方案分配的域名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">service: &#123;</span><br><span class="line">    host,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录地址，用于建立会话</span></span><br><span class="line">    loginUrl: <span class="string">`<span class="subst">$&#123;host&#125;</span>/login`</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试的请求地址，用于测试会话</span></span><br><span class="line">    requestUrl: <span class="string">`<span class="subst">$&#123;host&#125;</span>/user`</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<p>这样子就能愉快的在本地小程序开发了</p>
<p>顺便一提，最好在nts版本的php7.2.8以及加载了mod_cgi的apache或者开启php-fpm的Nginx服务器上跑，不然的话在进行Ajax操作时整个框架会发生崩溃。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>wechat</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>grpc折腾笔记(1)</title>
    <url>/2019/11/12/grpc%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>最近公司准备整项目，需要用到python 和 golang 协同工作，而如何协同这一问题，在restful api 和 grpc之间，我们选择了grpc 。</p>
<a id="more"></a>
<h2 id="Protoc-gen-go-报错"><a href="#Protoc-gen-go-报错" class="headerlink" title="Protoc-gen-go 报错"></a>Protoc-gen-go 报错</h2><p>首先第一条报错:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc-gen-go: program not found or is not executable</span><br></pre></td></tr></table></figure>
<p>一看就知道是没安装好对吧？咱们再安装一遍</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -d -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure>
<p>再跑一遍</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go_out=paths=source_relative:. inputs/x.proto</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc-gen-go: program not found or is not executable</span><br></pre></td></tr></table></figure>
<p>原因是并没有把 <code>$GOPATH/Bin</code> 放入环境变量，在我把go版本从12升到13，然后go mod 默认开启之后，这玩意似乎就消失不见了….得自己手动添加进环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOPATH</span>/bin:PATH</span><br></pre></td></tr></table></figure>
<h2 id="缺少使用方法"><a href="#缺少使用方法" class="headerlink" title="缺少使用方法"></a>缺少使用方法</h2><p>当我直接使用 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. *proto</span><br></pre></td></tr></table></figure>
<p>来生成go代码时，写到一半会发现只有<code>Response</code>和<code>Repuest</code>的结构体，而没有调用方法。</p>
<p>具体原因是我想生成grpc的代码，而没加上grpc的拓展….（我可真是傻逼）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go_out=plugins=grpc:. *proto</span><br></pre></td></tr></table></figure>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>这里是官方doc的一些小翻译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go_out=plugins=grpc,import_path=mypackage:. *.proto</span><br></pre></td></tr></table></figure>
<p>如果需要对protoc进行扩展的话，以上是一条标准的示例。</p>
<ul>
<li><code>paths=(import | source_relative)</code> - 声明生成文件的路径结构，默认为<code>import</code></li>
<li><code>pluigins=plugin1+plugin2</code> - 声明需要加载的拓展。</li>
<li><code>foo/bar.proto=quux/shme</code> -  加载grpc拓展时可以用到的，声明该 <code>foo/bar.proto</code> 与go包 <code>quux/shme</code>有所联系，直接加载引用包到文件</li>
</ul>
<p>以下这俩是废弃了的，不要使用</p>
<ul>
<li><code>import_prefix=xxx</code></li>
<li><code>import_path=foo/bar</code></li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>i7-9700k clover配置分享</title>
    <url>/2019/05/23/%E9%BB%91%E8%8B%B9%E6%9E%9C/</url>
    <content><![CDATA[<p>本人用的黑苹果是用做工作环境的，在10.14.4时是趋于稳定的，在更新完10.14.5后有很小几率会出现冻屏的情况，不知道是不是上次办公室突然断电造成的…..有点想买台ups了呜呜呜。</p>
<a id="more"></a> 
<p>CPU:  3.6GHz Core i7 9700k Intel</p>
<p>RAM: 32g DDR4 3200MHZ oc-&gt; 3333MHZ</p>
<p>Graphics: Intel UHD  Graphics 630 1536 MB</p>
<p>Disks: m9peg 1.02 tb</p>
<p>SMBIOS: Mac mini 2018 </p>
<p>地址在这里 ： <a href="https://github.com/JackyCZJ/Z370M-MORTAR-I7-9700K-M9PEG-CLOVER" target="_blank" rel="noopener">clover</a></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Clover</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
</search>
